@model IEnumerable<PriceTracker.Models.ProductClass>

@{
    ViewData["Title"] = "Lista Produktów";
    Layout = "~/Views/Shared/_PanelLayout.cshtml";
}

<h2>Lista produktów dla sklepu @ViewBag.StoreName</h2>
<p>Przypisano: <span id="scrapable-count">@ViewBag.ScrapableCount</span>/<span id="products-to-scrap">@ViewBag.ProductsToScrap</span> produktów z wyświetlanych <span id="total-products">@ViewBag.TotalProducts</span> produktów.</p>

<div>
    <button id="select-all" class="btn btn-primary">Zaznacz wszystkie</button>
    <button id="deselect-all" class="btn btn-secondary">Odznacz wszystkie</button>
</div>

<table class="table">
    <thead>
        <tr>
            <th>Nr</th>
            <th>Nazwa Produktu</th>
            <th>Kategoria</th>
            <th>Adres URL</th>
            <th>Do Scrapowania</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var product in Model.Select((value, index) => new { value, index }))
        {
            <tr>
                <td>@(product.index + 1)</td>
                <td>@product.value.ProductName</td>
                <td>@product.value.Category</td>
                <td><a href="@product.value.OfferUrl" target="_blank">@product.value.OfferUrl</a></td>
                <td>
                    <input type="checkbox" class="scrapable-checkbox" data-product-id="@product.value.ProductId" @(product.value.IsScrapable ? "checked" : "") />
                </td>
            </tr>
        }
    </tbody>
</table>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var checkboxes = document.querySelectorAll('.scrapable-checkbox');
            var selectAllButton = document.getElementById('select-all');
            var deselectAllButton = document.getElementById('deselect-all');
            var maxScrapable = @ViewBag.ProductsToScrap;
            var scrapableCount = @ViewBag.ScrapableCount;

            function updateScrapableCount(increment) {
                scrapableCount += increment;
                document.getElementById('scrapable-count').textContent = scrapableCount;
            }

            function sendBulkUpdateRequest(url, productIds, callback) {
                fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(productIds)
                })
                    .then(response => response.json())
                    .then(data => {
                        if (!data.success) {
                            alert(data.message || 'Wystąpił błąd podczas aktualizacji statusu scrapowania.');
                        } else {
                            callback();
                        }
                    })
                    .catch(error => {
                        console.error('There was a problem with your fetch operation:', error);
                    });
            }

            checkboxes.forEach(function (checkbox) {
                checkbox.addEventListener('change', function () {
                    var productId = this.getAttribute('data-product-id');
                    var isScrapable = this.checked;

                    console.log(`Product ID: ${productId}, Is Scrapable: ${isScrapable}`);

                    fetch('@Url.Action("UpdateScrapableProduct", "Product")?productId=' + productId + '&isScrapable=' + isScrapable, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (!data.success) {
                                alert(data.message || 'Wystąpił błąd podczas aktualizacji statusu scrapowania.');
                                checkbox.checked = !isScrapable; // Revert the change
                            } else {
                                updateScrapableCount(isScrapable ? 1 : -1);
                            }
                        })
                        .catch(error => {
                            console.error('There was a problem with your fetch operation:', error);
                        });
                });
            });

            selectAllButton.addEventListener('click', function () {
                var count = scrapableCount;
                var productIds = [];
                checkboxes.forEach(function (checkbox) {
                    if (count < maxScrapable && !checkbox.checked) {
                        checkbox.checked = true;
                        productIds.push(parseInt(checkbox.getAttribute('data-product-id')));
                        count++;
                    }
                });
                if (productIds.length > 0) {
                    sendBulkUpdateRequest('@Url.Action("UpdateMultipleScrapableProducts", "Product")?storeId=@ViewBag.StoreId', productIds, function () {
                        updateScrapableCount(productIds.length);
                    });
                }
            });

            deselectAllButton.addEventListener('click', function () {
                var productIds = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        checkbox.checked = false;
                        productIds.push(parseInt(checkbox.getAttribute('data-product-id')));
                    }
                });
                if (productIds.length > 0) {
                    sendBulkUpdateRequest('@Url.Action("ResetMultipleScrapableProducts", "Product")?storeId=@ViewBag.StoreId', productIds, function () {
                        updateScrapableCount(-productIds.length);
                    });
                }
            });
        });
    </script>
}
