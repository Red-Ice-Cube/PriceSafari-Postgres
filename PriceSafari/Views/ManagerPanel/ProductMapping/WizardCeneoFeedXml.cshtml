@{
    Layout = "~/Views/Shared/_PanelLayout.cshtml";
    var storeId = ViewBag.StoreId ?? 0;
    string existingMappingsJson = ViewBag.ExistingMappings ?? "[]";
}

<h2>Wizard Mapping Ceneo - storeId=@storeId</h2>

<!-- Górny panel z przyciskami -->
<div style="margin-bottom: 10px;">
    <form asp-action="ClearCeneoMappings"
          asp-controller="CeneoImportWizardXml"
          method="post"
          style="display:inline;">
        <input type="hidden" name="storeId" value="@storeId" />
        <button type="submit" style="background:red; color:white; padding:6px;">
            Usuń wszystkie mapowania
        </button>
    </form>

    <button id="extractProducts" style="margin-left:10px;">
        Wyciągnij produkty z XML (FRONT)
    </button>

    <button id="saveProductMapsInDb" style="margin-left:10px;">
        Zapisz w ProductMap
    </button>
</div>

<!-- Kolejny panel z dropdown i przyciskami -->
<div style="margin-bottom: 10px;">
    <label>Wybierz Pole: </label>
    <select id="fieldSelector">
        <option value="ExternalId">ExternalId</option>
        <option value="Url">Url</option>
        <option value="CeneoEan">CeneoEan</option>
        <option value="CeneoImage">CeneoImage</option>
        <option value="CeneoExportedName">CeneoExportedName</option>
    </select>
    <button id="saveMapping" style="margin-left:10px;">
        Zapisz Mapowanie
    </button>
    <button id="reloadMappings" style="margin-left:10px;">
        Załaduj mapowania
    </button>
</div>

<!-- Dwukolumnowy layout -->
<div style="display: flex; gap: 10px; width:100%;">
    <!-- LEWA kolumna: drzewo XML -->
    <div style="flex: 1; border:1px solid #ccc; height:900px; overflow:auto; padding:5px;">
        <h4>Struktura XML</h4>
        <div id="xmlContainer"></div>
    </div>

    <!-- PRAWA kolumna: Tabela mapowań + Podgląd JSON -->
    <div style="flex: 1; border:1px solid #ccc; height:900px; overflow:auto; padding:5px;">
        <h4>Mapa Pól i Podgląd</h4>

        <!-- Tabela mapowań -->
        <table id="mappingTable" border="1" cellpadding="5" style="border-collapse: collapse; width:100%;">
            <thead>
                <tr>
                    <th>Field</th>
                    <th>XPath</th>
                    <th>Liczba węzłów</th>
                    <th>Wartość pierwszego</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>

        <!-- Podgląd JSON (productMapsPreview) -->
        <pre id="productMapsPreview"
             style="border:1px solid #ccc; margin-top:10px; min-height:100px; padding:10px;">
        </pre>
    </div>
</div>

<script>
    //------------------------------------------------------------------
    // 1) Zmienne i wczytanie existingMappings
    //------------------------------------------------------------------
    let storeId = "@storeId";
    let existingMappingsJson = `@Html.Raw(existingMappingsJson)`;
    let existingMappings = [];
    try {
        existingMappings = JSON.parse(existingMappingsJson);
    } catch(e) {
        console.error("Błąd parsowania existingMappingsJson:", e);
        existingMappings = [];
    }

    console.log("Mapowania z bazy (Razor):", existingMappings);

    // Obiekt mapowań: fieldName -> { xpath, nodeCount, firstValue }
    let mappingForField = {
        "ExternalId": null,
        "Url": null,
        "CeneoEan": null,
        "CeneoImage": null,
        "CeneoExportedName": null
    };

    // Inicjujemy mapowania z bazy
    existingMappings.forEach(m => {
        mappingForField[m.fieldName] = {
            xpath: m.localName,
            nodeCount: 0,
            firstValue: ""
        };
    });

    let xmlDoc = null;
    let proxyUrl = `/CeneoImportWizardXml/ProxyXml?storeId=${storeId}`;

    //------------------------------------------------------------------
    // 2) Pobieranie XML i tworzenie drzewka
    //------------------------------------------------------------------
    fetch(proxyUrl)
      .then(resp => resp.text())
      .then(xmlStr => {
          let parser = new DOMParser();
          xmlDoc = parser.parseFromString(xmlStr, "application/xml");
          if (xmlDoc.documentElement.nodeName === "parsererror") {
              document.getElementById("xmlContainer").innerText =
                  "Błąd parsowania XML:\n" + xmlDoc.documentElement.textContent;
              return;
          }
          buildXmlTree(xmlDoc.documentElement, "");
          applyExistingMappings();
      })
      .catch(err => {
          document.getElementById("xmlContainer").innerText =
              "Błąd pobierania XML:\n" + err;
      });

    function buildXmlTree(node, parentPath) {
        let container = document.getElementById("xmlContainer");
        if (!parentPath && container.querySelector("ul") === null) {
            let ulRoot = document.createElement("ul");
            ulRoot.appendChild(createLi(node, parentPath));
            container.appendChild(ulRoot);
        } else {
            let rootUl = container.querySelector("ul");
            rootUl.appendChild(createLi(node, parentPath));
        }
    }

    function createLi(node, parentPath) {
        let li = document.createElement("li");
        li.classList.add("xml-node");

        let nodeName = node.nodeName;
        let currentPath = parentPath ? parentPath + "/" + nodeName : "/" + nodeName;
        li.setAttribute("data-xpath", currentPath);

        let b = document.createElement("b");
        b.innerText = nodeName;
        li.appendChild(b);

        if (node.children.length === 0 && node.textContent.trim()) {
            let span = document.createElement("span");
            span.innerText = " : " + node.textContent.trim();
            li.appendChild(span);
        }

        if (node.children.length > 0) {
            let ul = document.createElement("ul");
            Array.from(node.children).forEach(child => {
                ul.appendChild(createLi(child, currentPath));
            });
            li.appendChild(ul);
        }
        return li;
    }

    // Klik -> przypisanie mapowania dla wybranego pola
    document.addEventListener("click", function(e){
        let el = e.target.closest(".xml-node");
        if (!el) return;
        let xPath = el.getAttribute("data-xpath");
        let selectedField = document.getElementById("fieldSelector").value;

        // Usuwamy stare highlight dla wybranego pola
        document.querySelectorAll(`.highlight-${selectedField}`)
                .forEach(x => x.classList.remove(`highlight-${selectedField}`));

        let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${xPath}']`);
        sameNodes.forEach(n => n.classList.add(`highlight-${selectedField}`));

        let count = sameNodes.length;
        let firstVal = "";
        if (count > 0) {
            let sp = sameNodes[0].querySelector("span");
            if (sp) {
                firstVal = sp.innerText.replace(/^(\s*:\s*)/, "").trim();
            }
        }

        mappingForField[selectedField] = {
            xpath: xPath,
            nodeCount: count,
            firstValue: firstVal
        };
        renderMappingTable();
    });

    //------------------------------------------------------------------
    // 3) Wyświetlanie mapowań i highlightów
    //------------------------------------------------------------------
    function applyExistingMappings() {
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (!info || !info.xpath) continue;
            let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${info.xpath}']`);
            let count = sameNodes.length;
            let firstVal = "";
            if (count > 0) {
                let sp = sameNodes[0].querySelector("span");
                if (sp) {
                    firstVal = sp.innerText.replace(/^(\s*:\s*)/, "").trim();
                }
            }
            info.nodeCount = count;
            info.firstValue = firstVal;
            sameNodes.forEach(n => n.classList.add(`highlight-${fieldName}`));
        }
        renderMappingTable();
    }

    function clearAllHighlights() {
        Object.keys(mappingForField).forEach(field => {
            document.querySelectorAll(`.highlight-${field}`)
                    .forEach(el => el.classList.remove(`highlight-${field}`));
        });
    }

    function renderMappingTable() {
        let tbody = document.getElementById("mappingTable").querySelector("tbody");
        tbody.innerHTML = "";
        for (let fieldName in mappingForField) {
            // Pomijamy puste lub nieokreślone klucze
            if (!fieldName || fieldName === "undefined") continue;
            let info = mappingForField[fieldName];
            let tr = document.createElement("tr");
            if (!info) {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>-</td>
                  <td>0</td>
                  <td>-</td>
                `;
            } else {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>${info.xpath || "-"}</td>
                  <td>${info.nodeCount || 0}</td>
                  <td>${info.firstValue || "-"}</td>
                `;
            }
            tbody.appendChild(tr);
        }
    }

    //------------------------------------------------------------------
    // 4) Zapisywanie mapowań w bazie
    //------------------------------------------------------------------
    document.getElementById("saveMapping").addEventListener("click", function(){
        let finalMappings = [];
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (info && info.xpath) {
                finalMappings.push({
                    fieldName: fieldName,
                    localName: info.xpath
                });
            }
        }
        fetch(`/CeneoImportWizardXml/SaveCeneoMappings?storeId=${storeId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalMappings)
        })
        .then(r => r.json())
        .then(d => alert(d.message))
        .catch(err => console.error(err));
    });

    document.getElementById("reloadMappings").addEventListener("click", function(){
        fetch(`/CeneoImportWizardXml/GetCeneoMappings?storeId=${storeId}`)
          .then(r => r.json())
          .then(data => {
              console.log("Odebrano mapowania z bazy (reload):", data);
              clearAllHighlights();
              // Resetujemy wartości tylko dla istniejących kluczy
              Object.keys(mappingForField).forEach(f => mappingForField[f] = null);
              data.forEach(m => {
                  if(m.fieldName){  // dodajemy tylko, gdy fieldName jest określone
                      mappingForField[m.fieldName] = {
                          xpath: m.localName,
                          nodeCount: 0,
                          firstValue: ""
                      };
                  }
              });
              applyExistingMappings();
          })
          .catch(err => console.error("Błąd getCeneoMappings:", err));
    });

    //------------------------------------------------------------------
    // 5) Wyciąganie productMaps (na froncie) i zapisywanie w bazie
    //------------------------------------------------------------------
    document.getElementById("extractProducts").addEventListener("click", function(){
        if (!xmlDoc) {
            alert("Brak XML do parsowania");
            return;
        }
        // Wybieramy elementy: <item> (RSS) lub <entry> (Atom)
        let entries = xmlDoc.getElementsByTagName("item").length > 0
                      ? xmlDoc.getElementsByTagName("item")
                      : xmlDoc.getElementsByTagName("entry");
        let productMaps = [];

        for (let i = 0; i < entries.length; i++) {
            let entryNode = entries[i];
            let pm = {
                StoreId: storeId.toString(),
                ExternalId: getVal(entryNode, "ExternalId"),
                Url: getVal(entryNode, "Url"),
                CeneoEan: getVal(entryNode, "CeneoEan"),
                CeneoImage: getVal(entryNode, "CeneoImage"),
                CeneoExportedName: getVal(entryNode, "CeneoExportedName")
            };
            productMaps.push(pm);
        }
        console.log("Wyciągnięto productMaps(front):", productMaps);

        document.getElementById("productMapsPreview").textContent =
            JSON.stringify(productMaps, null, 2);
    });

    // Funkcja pobierająca wartość z elementu XML na podstawie mapowania
    function getVal(entryNode, fieldName) {
        let info = mappingForField[fieldName];
        if (!info || !info.xpath) return null;

        // Dynamicznie usuwamy znany prefiks, np. "/rss/channel/item/" lub "/feed/entry/"
        let trimmed = info.xpath;
        let possiblePrefixes = ["/rss/channel/item/", "/feed/entry/"];
        for (let i = 0; i < possiblePrefixes.length; i++) {
            if (trimmed.indexOf(possiblePrefixes[i]) === 0) {
                trimmed = trimmed.substring(possiblePrefixes[i].length);
                break;
            }
        }
        // Usuwamy namespace (np. "g:")
        if (trimmed.indexOf(':') !== -1) {
            trimmed = trimmed.split(':')[1];
        }
        let child = Array.from(entryNode.children)
            .find(e => e.localName === trimmed);
        return child ? child.textContent.trim() : null;
    }

    document.getElementById("saveProductMapsInDb").addEventListener("click", function(){
        let txt = document.getElementById("productMapsPreview").textContent.trim();
        if (!txt) {
            alert("Brak productMaps do zapisania!");
            return;
        }
        let productMaps = [];
        try {
            productMaps = JSON.parse(txt);
        } catch(e) {
            alert("Błędny JSON w productMapsPreview!");
            return;
        }
        fetch("/CeneoImportWizardXml/SaveProductMapsFromFront", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(productMaps)
        })
        .then(r => r.json())
        .then(d => alert("Zapisano: " + d.message))
        .catch(err => console.error(err));
    });

    // Na koniec wyświetlamy tabelę mapowań
    renderMappingTable();
</script>

<style>
    /* Dwukolumnowy układ */
    .xml-node {
        cursor: pointer;
        margin: 3px 0;
    }

    .highlight-ExternalId {
        background-color: rgba(255, 0, 0, 0.1);
    }

    .highlight-Url {
        background-color: rgba(0, 255, 0, 0.1);
    }

    .highlight-CeneoEan {
        background-color: rgba(0, 0, 255, 0.1);
    }

    .highlight-CeneoImage {
        background-color: rgba(255, 165, 0, 0.1);
    }

    .highlight-CeneoExportedName {
        background-color: rgba(255, 255, 0, 0.2);
    }

    #mappingTable {
        width: 100%;
    }

        #mappingTable th, #mappingTable td {
            padding: 4px 8px;
            text-align: left;
        }
</style>
