@{
    Layout = null; // Uproszczenie – brak layoutu
    var storeId = ViewBag.StoreId ?? 0;
    // Mapowania z bazy (JSON)
    var existingMappingsJson = ViewBag.ExistingMappings as string ?? "[]";
}

<h2>Wizard Mapping - storeId=@storeId</h2>

<!-- PRZYCISK USUWANIA MAPOWAŃ -->
<form asp-action="ClearGoogleMappings"
      asp-controller="GoogleImportWizardXml"
      method="post"
      style="margin-bottom:10px;">
    <input type="hidden" name="storeId" value="@storeId" />
    <button type="submit" style="background:red; color:white; padding:6px;">
        Usuń wszystkie mapowania
    </button>
</form>

<!-- Tabela z mapowaniami (Field / Xpath / Liczba / Wartość) -->
<table id="mappingTable" border="1" cellpadding="5" style="border-collapse: collapse;">
    <thead>
        <tr>
            <th>Field</th>
            <th>XPath</th>
            <th>Liczba węzłów</th>
            <th>Wartość pierwszego</th>
        </tr>
    </thead>
    <tbody>
        <!-- wypełniane dynamicznie w JS -->
    </tbody>
</table>

<div style="margin-top:10px;">
    <label>Wybierz Pole: </label>
    <select id="fieldSelector">
        <option value="ExternalId">ExternalId</option>
        <option value="Url">Url</option>
        <option value="GoogleEan">GoogleEan</option>
        <option value="GoogleImage">GoogleImage</option>
        <option value="GoogleExportedName">GoogleExportedName</option>
    </select>

    <button id="saveMapping" style="margin-left:10px;">Zapisz Mapowanie</button>
    <button id="reloadMappings" style="margin-left:10px;">Załaduj mapowania</button>
</div>

<!-- Miejsce na drzewo XML -->
<div id="xmlContainer" style="margin-top:20px; border:1px solid #ccc; padding:10px;"></div>

<script>
    // 1) Odczyt storeId i mapowań z bazy
    let storeId = "@storeId";
    let existingMappingsJson = `@existingMappingsJson`;
    let existingMappings = [];

    try {
        if (existingMappingsJson.trim() !== "") {
            existingMappings = JSON.parse(existingMappingsJson);
        }
    } catch(e) {
        console.error("Błąd parsowania existingMappings:", e);
    }
    console.log("Mapowania z bazy (Razor):", existingMappings);

    // 2) Obiekt do przechowywania mapowań w JS: field -> { xpath, nodeCount, firstValue }
    let mappingForField = {
        "ExternalId": null,
        "Url": null,
        "GoogleEan": null,
        "GoogleImage": null,
        "GoogleExportedName": null
    };

    // Zainicjuj w/g existingMappings (z bazy).
    // Uwaga: w bazie w polu localName mogłeś wcześniej trzymać, teraz trzymajmy "xpath".
    // Możesz nazwać tak samo lub dodać nową kolumnę w DB. Dla przykładu załóżmy, że
    // DB ma "LocalName" -> to będzie nasz Xpath
    existingMappings.forEach(m => {
        mappingForField[m.fieldName] = {
            xpath: m.localName,  // w DB mamy localName, a tu interpretujemy jako "xpath"
            nodeCount: 0,
            firstValue: ""
        };
    });

    // 3) Pobierz plik XML z Proxy
    let proxyUrl = `/GoogleImportWizardXml/ProxyXml?storeId=${storeId}`;
    fetch(proxyUrl)
        .then(r => r.text())
        .then(xmlString => {
            let parser = new DOMParser();
            let doc = parser.parseFromString(xmlString, "application/xml");
            if (doc.documentElement.nodeName === "parsererror") {
                document.getElementById("xmlContainer").innerText =
                    "Błąd parsowania XML:\n" + doc.documentElement.textContent;
                return;
            }
            // Zbuduj drzewo z PSEUDO-xpath
            buildXmlTree(doc.documentElement, ""); // start od ścieżki ""
            // Nałóż mapowania
            applyExistingMappings();
        })
        .catch(err => {
            document.getElementById("xmlContainer").innerText =
                "Błąd pobierania XML:\n" + err;
        });

    // 4) Funkcja do budowania drzewa rekurencyjnie, z "data-xpath"
    function buildXmlTree(node, parentPath) {
        let container = document.getElementById("xmlContainer");
        // Jeżeli to pierwszy węzeł, stwórz UL tylko raz
        if (!parentPath && container.querySelector("ul") === null) {
            let ulRoot = document.createElement("ul");
            ulRoot.appendChild(createLi(node, parentPath));
            container.appendChild(ulRoot);
        } else {
            // w pozostałych przypadkach parent's ul
            let rootUl = container.querySelector("ul");
            rootUl.appendChild(createLi(node, parentPath));
        }
    }

    // createLi – tworzy <li> z data-xpath
    function createLi(node, parentPath) {
        let li = document.createElement("li");
        li.classList.add("xml-node");

        // Budujemy xpath np. parentPath + "/" + nodeName
        // Jeżeli parentPath jest "" (root), to dajmy "/" + nodeName
        let nodeName = node.nodeName;
        let currentPath = parentPath
            ? parentPath + "/" + nodeName
            : "/" + nodeName; // root-level

        li.setAttribute("data-xpath", currentPath);

        // Tytuł
        let b = document.createElement("b");
        b.innerText = nodeName;
        li.appendChild(b);

        // Jeżeli brak dzieci i mamy text
        if (node.children.length === 0 && node.textContent.trim()) {
            let span = document.createElement("span");
            span.innerText = " : " + node.textContent.trim();
            li.appendChild(span);
        }

        // Rekurencja
        if (node.children.length > 0) {
            let ul = document.createElement("ul");
            // child
            Array.from(node.children).forEach(child => {
                ul.appendChild(createLi(child, currentPath));
            });
            li.appendChild(ul);
        }
        return li;
    }

    // 5) Nakładanie highlight wg mappingForField
    function applyExistingMappings() {
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (!info || !info.xpath) continue;

            let xPath = info.xpath;
            let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${xPath}']`);
            let count = sameNodes.length;
            let firstVal = "";
            if (count > 0) {
                let span = sameNodes[0].querySelector("span");
                if (span) {
                    firstVal = span.innerText.replace(/^(\s*:\s*)/, "").trim();
                }
            }
            info.nodeCount = count;
            info.firstValue = firstVal;

            sameNodes.forEach(n => n.classList.add(`highlight-${fieldName}`));
        }
        renderMappingTable();
    }

    // Usuwa wszystkie highlighty
    function clearAllHighlights() {
        Object.keys(mappingForField).forEach(field => {
            document.querySelectorAll(`.highlight-${field}`).forEach(el => {
                el.classList.remove(`highlight-${field}`);
            });
        });
    }

    // Obsługa kliknięcia w węzeł – bierzemy data-xpath
    document.addEventListener("click", function(e){
        let el = e.target.closest(".xml-node");
        if (!el) return;
        let xPath = el.getAttribute("data-xpath");
        let selectedField = document.getElementById("fieldSelector").value;

        // Usuwamy stare highlight dla tego field
        document.querySelectorAll(`.highlight-${selectedField}`).forEach(x => {
            x.classList.remove(`highlight-${selectedField}`);
        });

        // Podświetlamy wszystkie węzły o tym samym XPATH
        let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${xPath}']`);
        sameNodes.forEach(n => n.classList.add(`highlight-${selectedField}`));

        let count = sameNodes.length;
        let firstVal = "";
        if (count > 0) {
            let sp = sameNodes[0].querySelector("span");
            if (sp) {
                firstVal = sp.innerText.replace(/^(\s*:\s*)/, "").trim();
            }
        }

        // Zapisujemy w mappingForField
        mappingForField[selectedField] = {
            xpath: xPath,
            nodeCount: count,
            firstValue: firstVal
        };
        renderMappingTable();
    });

    // Rysuje tabelę
    function renderMappingTable() {
        let tbody = document.getElementById("mappingTable").querySelector("tbody");
        tbody.innerHTML = "";

        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            let tr = document.createElement("tr");
            if (!info) {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>-</td>
                  <td>0</td>
                  <td>-</td>
                `;
            } else {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>${info.xpath || "-"}</td>
                  <td>${info.nodeCount || 0}</td>
                  <td>${info.firstValue || "-"}</td>
                `;
            }
            tbody.appendChild(tr);
        }
    }

    // Zapis do bazy
    document.getElementById("saveMapping").addEventListener("click", function(){
        let finalMappings = [];
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (info) {
                // Uwaga: w bazie mamy (fieldName, localName),
                // a tu wysyłamy "xpath" => localName.
                finalMappings.push({
                    fieldName: fieldName,
                    localName: info.xpath // w DB zapiszemy w polu localName
                });
            }
        }
        fetch(`/GoogleImportWizardXml/SaveGoogleMappings?storeId=${storeId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalMappings)
        })
        .then(r => r.json())
        .then(d => alert(d.message))
        .catch(err => console.error(err));
    });

    // [NOWOŚĆ] Załaduj mapowania z bazy
    document.getElementById("reloadMappings").addEventListener("click", function(){
        fetch(`/GoogleImportWizardXml/GetGoogleMappings?storeId=${storeId}`)
          .then(r => r.json())
          .then(data => {
              console.log("Odebrano mapowania z bazy (reload):", data);
              // Czyścimy highlight
              clearAllHighlights();
              // Czyścimy mappingForField
              Object.keys(mappingForField).forEach(f => mappingForField[f] = null);

              // Ustawiamy wg data
              data.forEach(m => {
                  mappingForField[m.fieldName] = {
                      xpath: m.localName, // z DB w polu localName trzymamy Xpath
                      nodeCount: 0,
                      firstValue: ""
                  };
              });
              applyExistingMappings();
          })
          .catch(err => console.error("Błąd getGoogleMappings:", err));
    });

    // Na starcie rysujemy pustą tabelę
    renderMappingTable();
</script>

<style>
    .xml-node {
        cursor: pointer;
        margin: 3px 0;
    }

    .highlight-ExternalId {
        background-color: rgba(255, 0, 0, 0.1);
    }

    .highlight-Url {
        background-color: rgba(0, 255, 0, 0.1);
    }

    .highlight-GoogleEan {
        background-color: rgba(0, 0, 255, 0.1);
    }

    .highlight-GoogleImage {
        background-color: rgba(255, 165, 0, 0.1);
    }

    .highlight-GoogleExportedName {
        background-color: rgba(255, 255, 0, 0.2);
    }

    #mappingTable th, #mappingTable td {
        padding: 6px 12px;
        text-align: left;
    }
</style>
