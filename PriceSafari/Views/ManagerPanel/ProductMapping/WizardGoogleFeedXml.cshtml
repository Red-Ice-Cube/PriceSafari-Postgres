@{
    Layout = "~/Views/Shared/_PanelLayout.cshtml";
    var storeId = ViewBag.StoreId ?? 0;
    string existingMappingsJson = ViewBag.ExistingMappings ?? "[]";
}

<h2>Wizard Mapping Google - storeId=@storeId</h2>

<!-- Górny panel z przyciskami -->
<div style="margin-bottom: 10px;">
    <form asp-action="ClearGoogleMappings"
          asp-controller="GoogleImportWizardXml"
          method="post"
          style="display:inline;">
        <input type="hidden" name="storeId" value="@storeId" />
        <button type="submit" style="background:red; color:white; padding:6px;">
            Usuń wszystkie mapowania
        </button>
    </form>

    <button id="extractProducts" style="margin-left:10px;">
        Wyciągnij produkty z XML (FRONT)
    </button>

    <button id="saveProductMapsInDb" style="margin-left:10px;">
        Zapisz w ProductMap
    </button>
</div>

<!-- Element do wyświetlania liczby URL z parametrami -->
<div id="urlParamsInfo" style="margin-bottom:10px; font-weight:bold;">
    Liczba URL zawierających parametry: 0
</div>

<!-- Element do wyświetlania informacji o duplikatach -->
<div id="duplicatesInfo" style="margin-bottom:10px; font-weight:bold;">
    <!-- Informacja o unikatowych URL i kodach EAN pojawi się tutaj -->
</div>

<!-- Opcja usuwania duplikatów URL -->
<div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="removeDuplicateUrls">
        Usuń duplikaty URL (zostaw pierwszy wystąpienie)
    </label>
</div>

<!-- Opcja usuwania duplikatów EAN -->
<div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="removeDuplicateEans">
        Usuń duplikaty EAN (zostaw pierwszy wystąpienie)
    </label>
</div>

<!-- Nowy licznik finalnych węzłów po filtrach -->
<div id="finalNodesInfo" style="margin-bottom:10px; font-weight:bold;">
    Final nodes po filtrach: 0
</div>

<!-- Opcja czyszczenia parametrów URL -->
<div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="cleanUrlParameters" checked>
        Usuń parametry URL (usuwamy wszystko od znaku "?")
    </label>
</div>

<!-- Kolejny panel z dropdown i przyciskami -->
<div style="margin-bottom: 10px;">
    <label>Wybierz Pole: </label>
    <select id="fieldSelector">
        <option value="ExternalId">ExternalId</option>
        <option value="Url">Url</option>
        <option value="GoogleEan">GoogleEan</option>
        <option value="GoogleImage">GoogleImage</option>
        <option value="GoogleExportedName">GoogleExportedName</option>
        <option value="GoogleXMLPrice">GoogleXMLPrice</option>
        <option value="GoogleDeliveryXMLPrice">GoogleDeliveryXMLPrice</option>
    </select>
    <button id="saveMapping" style="margin-left:10px;">
        Zapisz Mapowanie
    </button>
    <button id="reloadMappings" style="margin-left:10px;">
        Załaduj mapowania
    </button>
</div>

<!-- Dwukolumnowy layout -->
<div style="display: flex; gap: 10px; width:100%;">
    <!-- LEWA kolumna: drzewo XML -->
    <div style="flex: 1; border:1px solid #ccc; height:900px; overflow:auto; padding:5px;">
        <h4>Struktura XML</h4>
        <div id="xmlContainer"></div>
    </div>

    <!-- PRAWA kolumna: Tabela mapowań + Podgląd JSON -->
    <div style="flex: 1; border:1px solid #ccc; height:900px; overflow:auto; padding:5px;">
        <h4>Mapa Pól i Podgląd</h4>

        <!-- Tabela mapowań -->
        <table id="mappingTable" border="1" cellpadding="5" style="border-collapse: collapse; width:100%;">
            <thead>
                <tr>
                    <th>Field</th>
                    <th>XPath</th>
                    <th>Liczba węzłów</th>
                    <th>Wartość pierwszego</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>

        <!-- Podgląd JSON (productMapsPreview) -->
        <pre id="productMapsPreview"
             style="border:1px solid #ccc; margin-top:10px; min-height:100px; padding:10px;">
        </pre>
    </div>
</div>

<script>
    let storeId = "@storeId";
    let existingMappingsJson = `@Html.Raw(existingMappingsJson)`;
    let existingMappings = [];
    try {
        existingMappings = JSON.parse(existingMappingsJson);
    } catch(e) {
        console.error("Błąd parsowania existingMappingsJson:", e);
        existingMappings = [];
    }

    console.log("Mapowania z bazy (Razor):", existingMappings);

    // Pola, w tym nowe ceny
    let mappingForField = {
        "ExternalId": null,
        "Url": null,
        "GoogleEan": null,
        "GoogleImage": null,
        "GoogleExportedName": null,
        "GoogleXMLPrice": null,
        "GoogleDeliveryXMLPrice": null
    };

    existingMappings.forEach(m => {
        if (m.fieldName) {
            mappingForField[m.fieldName] = {
                xpath: m.localName,
                nodeCount: 0,
                firstValue: ""
            };
        }
    });

    let xmlDoc = null;
    let proxyUrl = `/GoogleImportWizardXml/ProxyXml?storeId=${storeId}`;

    // ==================================
    // 1. Pobieranie XML przez fetch
    // ==================================
    fetch(proxyUrl)
      .then(resp => resp.text())
      .then(xmlStr => {
          let parser = new DOMParser();
          xmlDoc = parser.parseFromString(xmlStr, "application/xml");
          if (xmlDoc.documentElement.nodeName === "parsererror") {
              document.getElementById("xmlContainer").innerText =
                  "Błąd parsowania XML:\n" + xmlDoc.documentElement.textContent;
              return;
          }
          buildXmlTree(xmlDoc.documentElement, "");
          applyExistingMappings();
      })
      .catch(err => {
          document.getElementById("xmlContainer").innerText =
              "Błąd pobierania XML:\n" + err;
      });

    // ==================================
    // 2. Funkcje do budowy drzewa XML
    // ==================================
    function buildXmlTree(node, parentPath) {
        let container = document.getElementById("xmlContainer");
        if (!parentPath && container.querySelector("ul") === null) {
            let ulRoot = document.createElement("ul");
            ulRoot.appendChild(createLi(node, parentPath));
            container.appendChild(ulRoot);
        } else {
            let rootUl = container.querySelector("ul");
            rootUl.appendChild(createLi(node, parentPath));
        }
    }

    function createLi(node, parentPath) {
        let li = document.createElement("li");
        li.classList.add("xml-node");

        let nodeName = node.nodeName;
        let currentPath = parentPath ? parentPath + "/" + nodeName : "/" + nodeName;
        li.setAttribute("data-xpath", currentPath);

        let b = document.createElement("b");
        b.innerText = nodeName;
        li.appendChild(b);

        if (node.children.length === 0 && node.textContent.trim()) {
            let span = document.createElement("span");
            span.innerText = " : " + node.textContent.trim();
            li.appendChild(span);
        }

        if (node.children.length > 0) {
            let ul = document.createElement("ul");
            Array.from(node.children).forEach(child => {
                ul.appendChild(createLi(child, currentPath));
            });
            li.appendChild(ul);
        }
        return li;
    }

    // ==================================
    // 3. Klik w węzeł = przypisanie Xpath
    // ==================================
    document.addEventListener("click", function(e){
        let el = e.target.closest(".xml-node");
        if (!el) return;
        let xPath = el.getAttribute("data-xpath");
        let selectedField = document.getElementById("fieldSelector").value;

        document.querySelectorAll(`.highlight-${selectedField}`)
                .forEach(x => x.classList.remove(`highlight-${selectedField}`));

        let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${xPath}']`);
        sameNodes.forEach(n => n.classList.add(`highlight-${selectedField}`));

        let count = sameNodes.length;
        let firstVal = "";
        if (count > 0) {
            let sp = sameNodes[0].querySelector("span");
            if (sp) {
                firstVal = sp.innerText.replace(/^(\s*:\s*)/, "").trim();
            }
        }

        mappingForField[selectedField] = {
            xpath: xPath,
            nodeCount: count,
            firstValue: firstVal
        };
        renderMappingTable();
    });

    // ==================================
    // 4. Przywracanie mapowań z bazy
    // ==================================
    function applyExistingMappings() {
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (!info || !info.xpath) continue;
            let sameNodes = document.querySelectorAll(`.xml-node[data-xpath='${info.xpath}']`);
            let count = sameNodes.length;
            let firstVal = "";
            if (count > 0) {
                let sp = sameNodes[0].querySelector("span");
                if (sp) {
                    firstVal = sp.innerText.replace(/^(\s*:\s*)/, "").trim();
                }
            }
            info.nodeCount = count;
            info.firstValue = firstVal;
            sameNodes.forEach(n => n.classList.add(`highlight-${fieldName}`));
        }
        renderMappingTable();
    }

    function clearAllHighlights() {
        Object.keys(mappingForField).forEach(field => {
            document.querySelectorAll(`.highlight-${field}`)
                    .forEach(el => el.classList.remove(`highlight-${field}`));
        });
    }

    // ==================================
    // 5. Render mapowań w tabelce
    // ==================================
    function renderMappingTable() {
        let tbody = document.getElementById("mappingTable").querySelector("tbody");
        tbody.innerHTML = "";
        for (let fieldName in mappingForField) {
            if (!fieldName || fieldName === "undefined") continue;
            let info = mappingForField[fieldName];
            let tr = document.createElement("tr");
            if (!info) {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>-</td>
                  <td>0</td>
                  <td>-</td>
                `;
            } else {
                tr.innerHTML = `
                  <td>${fieldName}</td>
                  <td>${info.xpath || "-"}</td>
                  <td>${info.nodeCount || 0}</td>
                  <td>${info.firstValue || "-"}</td>
                `;
            }
            tbody.appendChild(tr);
        }
    }

    // ==================================
    // 6. Zapis mapowań w bazie
    // ==================================
    document.getElementById("saveMapping").addEventListener("click", function(){
        let finalMappings = [];
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            if (info && info.xpath) {
                finalMappings.push({
                    fieldName: fieldName,
                    localName: info.xpath
                });
            }
        }
        fetch(`/GoogleImportWizardXml/SaveGoogleMappings?storeId=${storeId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalMappings)
        })
        .then(r => r.json())
        .then(d => alert(d.message))
        .catch(err => console.error(err));
    });

    // ==================================
    // 7. Ponowne wczytanie mapowań
    // ==================================
    document.getElementById("reloadMappings").addEventListener("click", function(){
        fetch(`/GoogleImportWizardXml/GetGoogleMappings?storeId=${storeId}`)
          .then(r => r.json())
          .then(data => {
              console.log("Odebrano mapowania z bazy (reload):", data);
              clearAllHighlights();

              Object.keys(mappingForField).forEach(f => mappingForField[f] = null);
              data.forEach(m => {
                  if(m.fieldName){
                      mappingForField[m.fieldName] = {
                          xpath: m.localName,
                          nodeCount: 0,
                          firstValue: ""
                      };
                  }
              });
              applyExistingMappings();
          })
          .catch(err => console.error("Błąd getGoogleMappings:", err));
    });

    // ==================================
    // 8. Funkcja parsePrice - wyłuskuje liczbę z tekstu "Koszt 123,45 PLN" -> "123.45"
    // ==================================
    function parsePrice(value) {
        if (!value) return null;
        let match = value.match(/([\d]+([.,]\d+)?)/);
        if (!match) return null;
        let numericString = match[1].replace(',', '.');  // zamieniamy ewentualny przecinek na kropkę
        let floatVal = parseFloat(numericString);
        if (isNaN(floatVal)) return null;
        return floatVal.toFixed(2); // zapisujemy jako "xx.xx"
    }

    // ==================================
    // 9. Wyciąganie produktów z XML
    // ==================================
    function extractProductsFromXml() {
        if (!xmlDoc) {
            alert("Brak XML do parsowania");
            return;
        }
        let entries = xmlDoc.getElementsByTagName("item").length > 0
                      ? xmlDoc.getElementsByTagName("item")
                      : xmlDoc.getElementsByTagName("entry");
        let productMaps = [];
        let countUrlsWithParams = 0;
        let removeParams = document.getElementById("cleanUrlParameters").checked;

        for (let i = 0; i < entries.length; i++) {
            let entryNode = entries[i];
            let pm = {
                StoreId: storeId.toString(),
                ExternalId: getVal(entryNode, "ExternalId"),
                Url: getVal(entryNode, "Url"),
                GoogleEan: getVal(entryNode, "GoogleEan"),
                GoogleImage: getVal(entryNode, "GoogleImage"),
                GoogleExportedName: getVal(entryNode, "GoogleExportedName"),

                // Dla cen wyłuskujemy liczbę z "xxx PLN" itp.
                GoogleXMLPrice: parsePrice( getVal(entryNode, "GoogleXMLPrice") ),
                GoogleDeliveryXMLPrice: parsePrice( getVal(entryNode, "GoogleDeliveryXMLPrice") )
            };

            // Usuwanie parametrów z URL
            if (pm.Url) {
                let qIdx = pm.Url.indexOf('?');
                if (qIdx !== -1) {
                    countUrlsWithParams++;
                    if (removeParams) {
                        pm.Url = pm.Url.substring(0, qIdx);
                    }
                }
            }

            // Przykład: jeśli EAN jest pusty, pomijamy
            if (!pm.GoogleEan || pm.GoogleEan.trim() === "") {
                continue;
            }

            productMaps.push(pm);
        }

        console.log("Wyciągnięto productMaps(front):", productMaps);
        console.log("Liczba URLi zawierających parametry:", countUrlsWithParams);

        // Ustawiamy JSON w polu podglądu
        let previewText = JSON.stringify(productMaps, null, 2);
        document.getElementById("productMapsPreview").textContent = previewText;

        // Informacja o parametrach URL
        document.getElementById("urlParamsInfo").textContent =
            "Liczba URL zawierających parametry: " + countUrlsWithParams;

        // Ewentualna deduplikacja URL
        if (document.getElementById("removeDuplicateUrls").checked) {
            let seen = {};
            let deduped = [];
            productMaps.forEach(pm => {
                if(pm.Url) {
                    if (!seen[pm.Url]) {
                        seen[pm.Url] = true;
                        deduped.push(pm);
                    }
                } else {
                    deduped.push(pm);
                }
            });
            productMaps = deduped;
            document.getElementById("productMapsPreview").textContent =
                JSON.stringify(productMaps, null, 2);
        }

        // Ewentualna deduplikacja EAN
        if (document.getElementById("removeDuplicateEans").checked) {
            let seenEan = {};
            let dedupedEan = [];
            productMaps.forEach(pm => {
                if(pm.GoogleEan) {
                    if (!seenEan[pm.GoogleEan]) {
                        seenEan[pm.GoogleEan] = true;
                        dedupedEan.push(pm);
                    }
                } else {
                    dedupedEan.push(pm);
                }
            });
            productMaps = dedupedEan;
            document.getElementById("productMapsPreview").textContent =
                JSON.stringify(productMaps, null, 2);
        }

        // Finalna liczba węzłów
        document.getElementById("finalNodesInfo").textContent =
            "Final nodes po filtrach: " + productMaps.length;

        // Sprawdzamy duplikaty
        checkDuplicates(productMaps);
    }

    // ==================================
    // 10. Funkcja sprawdzająca duplikaty
    // ==================================
    function checkDuplicates(productMaps) {
        let urlCounts = {};
        let eanCounts = {};

        productMaps.forEach(pm => {
            if(pm.Url) {
                urlCounts[pm.Url] = (urlCounts[pm.Url] || 0) + 1;
            }
            if(pm.GoogleEan) {
                eanCounts[pm.GoogleEan] = (eanCounts[pm.GoogleEan] || 0) + 1;
            }
        });

        let totalUniqueUrls = Object.keys(urlCounts).length;
        let duplicateUrls = 0;
        for(let key in urlCounts) {
            if(urlCounts[key] > 1) {
                duplicateUrls++;
            }
        }

        let totalUniqueEans = Object.keys(eanCounts).length;
        let duplicateEans = 0;
        for(let key in eanCounts) {
            if(eanCounts[key] > 1) {
                duplicateEans++;
            }
        }

        let urlMessage = `Unikalnych URL: ${totalUniqueUrls} `;
        urlMessage += duplicateUrls > 0
                      ? `<span style="color:red;">(Duplikatów: ${duplicateUrls})</span>`
                      : `(Brak duplikatów)`;

        let eanMessage = `Unikalnych kodów EAN: ${totalUniqueEans} `;
        eanMessage += duplicateEans > 0
                      ? `<span style="color:red;">(Duplikatów: ${duplicateEans})</span>`
                      : `(Brak duplikatów)`;

        document.getElementById("duplicatesInfo").innerHTML =
            urlMessage + "<br>" + eanMessage;
    }

    // ==================================
    // 11. Obsługa przycisków 'extractProducts' i checkboksów
    // ==================================
    document.getElementById("extractProducts").addEventListener("click", function(){
        extractProductsFromXml();
    });

    document.getElementById("cleanUrlParameters").addEventListener("change", function(){
        extractProductsFromXml();
    });

    document.getElementById("removeDuplicateUrls").addEventListener("change", function(){
        extractProductsFromXml();
    });

    document.getElementById("removeDuplicateEans").addEventListener("change", function(){
        extractProductsFromXml();
    });

    // ==================================
    // 12. Funkcja getVal -> obsługuje multi-level path
    // ==================================
    function getVal(entryNode, fieldName) {
        let info = mappingForField[fieldName];
        if (!info || !info.xpath) return null;

        let path = info.xpath;

        // Usuwamy najczęstsze prefiksy (np. "/rss/channel/item/")
        let possiblePrefixes = ["/rss/channel/item/", "/feed/entry/"];
        for (let i = 0; i < possiblePrefixes.length; i++) {
            if (path.startsWith(possiblePrefixes[i])) {
                path = path.substring(possiblePrefixes[i].length);
                break;
            }
        }

        // Usuwamy ewentualny leading slash
        if (path.startsWith("/")) {
            path = path.substring(1);
        }

        // Rozbijamy po slashach, żeby obsłużyć np. "g:shipping/g:price"
        let segments = path.split('/');

        // Schodzimy w dół węzłów
        let currentNode = entryNode;
        for (let seg of segments) {
            // Jeśli np. "g:shipping", to po dwukropku zostaje "shipping"
            if (seg.indexOf(':') !== -1) {
                seg = seg.split(':')[1];
            }
            if (!seg) {
                return null;
            }
            // Znajdujemy childa o localName == seg
            let child = Array.from(currentNode.children).find(e => e.localName === seg);
            if (!child) {
                return null;
            }
            currentNode = child;
        }
        // Zwracamy textContent
        return currentNode.textContent.trim();
    }

    // ==================================
    // 13. Zapis do bazy (przycisk "saveProductMapsInDb")
    // ==================================
    document.getElementById("saveProductMapsInDb").addEventListener("click", function(){
        let txt = document.getElementById("productMapsPreview").textContent.trim();
        if (!txt) {
            alert("Brak productMaps do zapisania!");
            return;
        }
        let productMaps = [];
        try {
            productMaps = JSON.parse(txt);
        } catch(e) {
            alert("Błędny JSON w productMapsPreview!");
            return;
        }
        fetch("/GoogleImportWizardXml/SaveProductMapsFromFront", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(productMaps)
        })
        .then(r => r.json())
        .then(d => alert("Zapisano: " + d.message))
        .catch(err => console.error(err));
    });

    // Na końcu - pierwsze wyrenderowanie tabeli mapowań
    renderMappingTable();
</script>



<style>
    /* Dwukolumnowy układ */
    .xml-node {
        cursor: pointer;
        margin: 3px 0;
    }

    .highlight-ExternalId {
        background-color: rgba(255, 0, 0, 0.1);
    }

    .highlight-Url {
        background-color: rgba(0, 255, 0, 0.1);
    }

    .highlight-GoogleEan {
        background-color: rgba(0, 0, 255, 0.1);
    }

    .highlight-GoogleImage {
        background-color: rgba(255, 165, 0, 0.1);
    }

    .highlight-GoogleExportedName {
        background-color: rgba(255, 255, 0, 0.2);
    }

    .highlight-GoogleXMLPrice {
        background-color: rgba(255, 192, 203, 0.2); /* pastelowy róż */
    }

    .highlight-GoogleDeliveryXMLPrice {
        background-color: rgba(255, 165, 0, 0.2); /* pastelowy pomarańcz */
    }


    #mappingTable {
        width: 100%;
    }

        #mappingTable th, #mappingTable td {
            padding: 4px 8px;
            text-align: left;
        }
</style>
