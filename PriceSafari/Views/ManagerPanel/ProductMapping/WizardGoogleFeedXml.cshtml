@{
    Layout = null; // Dla uproszczenia
    var storeId = ViewBag.StoreId ?? 0;
}

<h2>Wizard Mapping - storeId=@storeId</h2>

<!-- Tabela z informacjami o mapowaniach -->
<table id="mappingTable" border="1" cellpadding="5" style="border-collapse: collapse;">
    <thead>
        <tr>
            <th>Field</th>
            <th>Node Name</th>
            <th>Liczba węzłów</th>
            <th>Wartość pierwszego</th>
        </tr>
    </thead>
    <tbody>
        <!-- Zapełniane dynamicznie w JS -->
    </tbody>
</table>

<!-- Kontrolki do wyboru pola -->
<div style="margin-top:10px;">
    <label>Wybierz Pole: </label>
    <select id="fieldSelector">
        <option value="ExternalId">ExternalId</option>
        <option value="Url">Url</option>
        <option value="GoogleEan">GoogleEan</option>
        <option value="GoogleImage">GoogleImage</option>
        <option value="GoogleExportedName">GoogleExportedName</option>
    </select>
    <button id="saveMapping" style="margin-left:10px;">Zapisz Mapowanie</button>
</div>

<!-- Miejsce na drzewo XML -->
<div id="xmlContainer" style="margin-top:20px; border:1px solid #ccc; padding:10px;">
    <!-- Drzewo wczytywane w JS -->
</div>

<script>
    let storeId = "@storeId";
    // Proxy, które zwraca surowy plik XML
    let proxyUrl = `/GoogleImportWizardXml/ProxyXml?storeId=${storeId}`;

    // Obiekt do przechowywania info o aktualnym mapowaniu
    // Kluczem jest FieldName, a wartość to { localName, nodeCount, firstValue }
    let mappingForField = {
        "ExternalId": null,
        "Url": null,
        "GoogleEan": null,
        "GoogleImage": null,
        "GoogleExportedName": null
    };

    // 1) Pobieramy plik XML z proxy
    fetch(proxyUrl)
      .then(resp => resp.text())
      .then(xmlString => {
          let parser = new DOMParser();
          let doc = parser.parseFromString(xmlString, "application/xml");

          // Sprawdź błędy parsera
          if (doc.documentElement.nodeName === "parsererror") {
              document.getElementById("xmlContainer").innerText =
                  "Błąd parsowania XML:\n" + doc.documentElement.textContent;
              return;
          }

          buildXmlTree(doc.documentElement);
      })
      .catch(err => {
          document.getElementById("xmlContainer").innerText =
              "Błąd pobierania pliku XML:\n" + err;
      });

    // 2) Funkcja do budowania drzewka w <ul><li>
    function buildXmlTree(rootNode) {
        let container = document.getElementById("xmlContainer");
        let ul = document.createElement("ul");
        let rootLi = createLi(rootNode);
        ul.appendChild(rootLi);
        container.appendChild(ul);
    }

    function createLi(node) {
        let li = document.createElement("li");
        li.classList.add("xml-node");

        let nodeName = node.nodeName;
        li.setAttribute("data-name", nodeName);

        // Tytuł
        let b = document.createElement("b");
        b.innerText = nodeName;
        li.appendChild(b);

        // Jeżeli brak dzieci i mamy text => <span>
        if (node.children.length === 0 && node.textContent.trim()) {
            let span = document.createElement("span");
            span.innerText = " : " + node.textContent.trim();
            li.appendChild(span);
        }

        // Rekurencja
        if (node.children.length > 0) {
            let childUl = document.createElement("ul");
            for (let child of node.children) {
                childUl.appendChild(createLi(child));
            }
            li.appendChild(childUl);
        }

        return li;
    }

    // 3) Nasłuchujemy kliknięcia w węzeł XML
    document.addEventListener("click", function(e){
        let target = e.target.closest(".xml-node");
        if (!target) return; // klik poza węzłem

        let nodeName = target.getAttribute("data-name");
        // Które pole wybrał user
        let selectedField = document.getElementById("fieldSelector").value;

        // Znajdź wszystkie węzły o takiej nazwie
        let sameNodes = document.querySelectorAll(`.xml-node[data-name='${nodeName}']`);
        let nodeCount = sameNodes.length;
        let firstValue = "";
        if (nodeCount > 0) {
            let span = sameNodes[0].querySelector("span");
            if (span) {
                firstValue = span.innerText.replace(/^(\s*:\s*)/, "").trim();
            }
        }

        // Zapisz w mappingForField
        mappingForField[selectedField] = {
            localName: nodeName,
            nodeCount: nodeCount,
            firstValue: firstValue
        };

        // Podświetlanie (najpierw usuń stare highlight dla tego selectedField)
        document.querySelectorAll(`.highlight-${selectedField}`).forEach(x => {
            x.classList.remove(`highlight-${selectedField}`);
        });
        // Dodaj highlight węzłom, które user kliknął
        sameNodes.forEach(n => n.classList.add(`highlight-${selectedField}`));

        // Renderuj tabelę
        renderMappingTable();
    });

    // 4) Funkcja do odświeżenia tabeli
    function renderMappingTable() {
        let tbody = document.getElementById("mappingTable").querySelector("tbody");
        tbody.innerHTML = ""; // czyścimy

        // Przechodzimy po polach
        for (let fieldName in mappingForField) {
            let info = mappingForField[fieldName];
            let tr = document.createElement("tr");

            if (info === null) {
                // Brak mapowania
                tr.innerHTML = `
                    <td>${fieldName}</td>
                    <td>-</td>
                    <td>0</td>
                    <td>-</td>
                `;
            } else {
                tr.innerHTML = `
                    <td>${fieldName}</td>
                    <td>${info.localName}</td>
                    <td>${info.nodeCount}</td>
                    <td>${info.firstValue}</td>
                `;
            }
            tbody.appendChild(tr);
        }
    }

    // 5) Gdy user klika „Zapisz Mapowanie” – wysyłamy do serwera
    document.getElementById("saveMapping").addEventListener("click", function(){
        // Konwertujemy mappingForField w tablicę (jeśli serwer tak oczekuje),
        // lub wysyłamy w takiej formie
        let finalMappings = [];
        for (let fieldName in mappingForField) {
            let m = mappingForField[fieldName];
            if (m) {
                finalMappings.push({
                    fieldName: fieldName,
                    localName: m.localName
                    // nodeCount, firstValue – opcjonalnie
                });
            }
        }

        let url = `/GoogleImportWizardXml/SaveGoogleMappings?storeId=${storeId}`;
        fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(finalMappings)
        })
        .then(resp => resp.json())
        .then(data => {
            alert(data.message);
        })
        .catch(err => console.error(err));
    });

    // Inicjalnie renderuj pustą tabelę (same "-")
    renderMappingTable();
</script>

<style>
    .xml-node {
        cursor: pointer;
        margin: 3px 0;
    }
    /* Różne kolory dla różnych pól */
    .highlight-ExternalId {
        background-color: rgba(255, 0, 0, 0.1);
    }

    .highlight-Url {
        background-color: rgba(0, 255, 0, 0.1);
    }

    .highlight-GoogleEan {
        background-color: rgba(0, 0, 255, 0.1);
    }

    .highlight-GoogleImage {
        background-color: rgba(255, 165, 0, 0.1);
    }

    .highlight-GoogleExportedName {
        background-color: rgba(255, 255, 0, 0.2);
    }

    #mappingTable th, #mappingTable td {
        padding: 6px 12px;
        text-align: left;
    }
</style>
