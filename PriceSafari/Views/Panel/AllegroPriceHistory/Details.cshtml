@{
    Layout = "~/Views/Shared/_PanelLayout.cshtml";
    ViewData["Title"] = "Szczegóły Cen Allegro";
    var storeId = ViewBag.StoreId;
    var productId = ViewBag.ProductId;
    var productName = ViewBag.ProductName as string;
    var storeName = ViewBag.StoreName as string;
    var allegroOfferUrl = ViewBag.AllegroOfferUrl as string;
}

<style>
    .price-trend-section {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-top: 25px;
    }

    #customTrendTooltip {
        width: 450px;
    }

    .price-trend__main-panel {
        flex: 1;
        min-width: 480px;
        display: flex;
        flex-direction: column;
        height: 65vh;
    }

    .price-trend__chart-area {
        width: 100%;
        flex-grow: 1;
        min-height: 300px;
        position: relative;
        margin-bottom: 10px;
    }

    .price-trend__controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 5px;
        align-self: center;
        justify-self: center;
        width: 93%;
        box-sizing: border-box;
        flex-shrink: 0;
    }

    .price-trend__alpha-slider-wrapper {
        flex-grow: 1;
        margin-right: 20px;
        display: flex;
        align-items: center;
        max-width: 300px;
    }

        .price-trend__alpha-slider-wrapper input[type=range] {
            width: 100%;
            cursor: pointer;
        }

    #exportExcelBtn {
        white-space: nowrap;
        flex-shrink: 0;
    }

    .price-trend__tooltip-panel {
        flex-basis: 370px;
        flex-shrink: 0;
        border-left: 1px solid #e0e0e0;
        padding-left: 20px;
        overflow-y: auto;
    }

    .offer-badge {
        display: inline-block;
        padding: 2px 5px;
        font-size: 0.7rem;
        font-weight: bold;
        color: white;
        border-radius: 4px;
        margin-left: 4px;
        vertical-align: middle;
    }

    .badge-bpg {
        background-color: #169A23;
    }

    .badge-top {
        background-color: #9c27b0;
    }

    .badge-super {
        background-color: #ff9800;
    }

</style>

<div class="Vert" data-store-name="@storeName">
    <div class="Page-Box">
        <div style="display:flex; width:100%; justify-content:space-between;">
            <div style="font-weight: 300; font-size: 22px;">
                @productName
            </div>
            <div style="margin-top:4px;">
                <button type="button" id="showTableBtn" class="button-active">
                    Ranking
                </button>
                <button type="button" id="showChartBtn" class="button-inactive">
                    Wykres
                </button>
            </div>
        </div>

        <div class="form-check-orders" style="margin-bottom:16px;">
            <div id="lastScrapeInfo"></div>
        </div>

        <div style="display: flex; width: 100%; gap: 48px;  align-items: flex-end; justify-content:space-between;">
            @if (!string.IsNullOrEmpty(allegroOfferUrl))
            {
                <a href="@allegroOfferUrl" class="Button-Page-Small" style="margin-bottom: 8px;" target="_blank" rel="noopener noreferrer">
                    <img src="/images/AllegroIcon.png" alt="Allegro Icon" style="width:18px; height:18px; margin-right: 5px;" /> Zobacz na Allegro
                </a>
            }
            <div id="chartContainer" style="flex-shrink: 0; width: 50%; height: 130px;">
                <canvas id="priceBarChart"></canvas>
            </div>
        </div>

        <div id="priceTableContainer" class="Vert-table">
            <table class="table-orders" id="priceTable">
                <thead>
                    <tr>
                        <th></th>
                        <th id="storeHeader">Sklep</th>
                        <th>Cena</th>
                        <th>Różnica</th>
                        <th>Ads</th>
                        <th>Koszt wysyłki</th>
                        <th>Dostawa</th>
                        <th>Smart</th>
                        <th id="popularityHeader">Sprzedaż</th>
                        <th>Oferta w katalogu</th>
                        <th>Źródło</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>

        <div id="trendChartContainer" class="price-trend-section" style="display: none;">
            <div class="price-trend__main-panel">
                <div class="price-trend__chart-area">
                    <div id="trendChart" style="width: 100%; height: 100%;"></div>
                </div>
                <div class="price-trend__controls">
                    <div class="price-trend__alpha-slider-wrapper">
                        <input type="range" id="grayAlphaRange" min="0" max="0.6" step="0.01" value="0.3">
                    </div>
                    <button type="button" id="exportExcelBtn" class="Button-Page-Small" title="Eksportuj dane historii cen do pliku Excel">
                        <i class="fas fa-file-excel" style="margin-right: 5px;"></i> Excel
                    </button>
                </div>
            </div>
            <div id="customTrendTooltip" class="price-trend__tooltip-panel">
            </div>
        </div>
    </div>
</div>

<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loader"></div>
</div>

@section Scripts {
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>

    <script>
         document.addEventListener("DOMContentLoaded", function () {

            const myStoreName = "@Html.Raw(System.Web.HttpUtility.JavaScriptStringEncode(storeName))";
            const storeId = @storeId;
            const productId = @productId;
            let chartInstance = null;
            const myStoreLower = myStoreName ? myStoreName.toLowerCase().trim() : '';
            const loadingOverlay = document.getElementById('loadingOverlay');

            function renderDeliveryInfo(deliveryTime) {
                if (deliveryTime === null || deliveryTime === undefined) return '<span>-</span>';
                let text = '', className = '';
                switch (deliveryTime) {
                    case 1: text = 'Jutro'; className = 'Delivery1'; break;
                    case 2: text = 'Pojutrze'; className = 'Delivery2'; break;
                    case 3: text = 'Długa dostawa'; className = 'Delivery3'; break;
                    default: return '<span>-</span>';
                }
                return `<div class="${className}">${text}</div>`;
            }

            function renderShippingCost(cost) {
                if (cost === null || cost === undefined) return '<span>-</span>';
                if (cost === 0) return `<div class="FreeShipping">Darmowa</div>`;
                return `<div class="PaidShipping">${cost.toFixed(2)} PLN</div>`;
            }

            function getColorClass(item, allOffers, myOffer, setPrice1, setPrice2) {
                const myPrice = myOffer ? myOffer.price : null;
                const minPrice = Math.min(...allOffers.map(o => o.price));
                const offersWithMinPrice = allOffers.filter(o => o.price === minPrice);
                const isUniqueBestPrice = item.price === minPrice && offersWithMinPrice.length === 1;
                const isSharedBestPrice = item.price === minPrice && offersWithMinPrice.length > 1;
                if (isSharedBestPrice) return "prGood";
                if (isUniqueBestPrice) {
                    const secondMinPriceOffer = [...allOffers].filter(o => o.price > minPrice).sort((a, b) => a.price - b.price)[0];
                    const savings = secondMinPriceOffer ? secondMinPriceOffer.price - item.price : null;
                    return (savings != null && savings >= 0.01 && savings <= setPrice1) ? "prIdeal" : "prToLow";
                }
                if (myPrice && item.price > minPrice) {
                    const priceDifference = item.price - myPrice;
                    return priceDifference < setPrice2 ? "prMid" : "prToHigh";
                }
                return "prToHigh";
            }

                   function renderTable(offersData, totalPopularity, setPrice1, setPrice2, mainOfferId) {
            const tbody = document.querySelector("#priceTable tbody");
            tbody.innerHTML = '';

            document.getElementById('storeHeader').textContent = `Sklep (${offersData.length})`;
            document.getElementById('popularityHeader').textContent = `Kupiło ${totalPopularity} osb.`;

            const myCurrentOfferForDiff = offersData.find(o => o.targetProductId === productId);
            const basePrice = myCurrentOfferForDiff ? myCurrentOfferForDiff.price : 0;

            offersData.forEach(item => {
                const isMyStore = item.sellerName.toLowerCase().trim() === myStoreLower;
                const priceDifference = basePrice > 0 ? item.price - basePrice : 0;
                const percentageDifference = basePrice > 0 && basePrice !== 0 ? (priceDifference / basePrice) * 100 : 0;

                const colorClass = getColorClass(item, offersData, myCurrentOfferForDiff, setPrice1, setPrice2);
                const tr = document.createElement('tr');
                tr.className = `price-row ${colorClass}`;

                let diffHtml = '<div class="priceBox-diff-neutral">0,00 PLN (0,00 %)</div>';

                if (basePrice > 0 && priceDifference !== 0) {
                    const diffClass = priceDifference < 0 ? 'priceBox-diff-up' : 'priceBox-diff-down';
                    const sign = priceDifference > 0 ? '+' : '';
                    diffHtml = `<div class="${diffClass}">${sign}${priceDifference.toFixed(2)} PLN (${sign}${percentageDifference.toFixed(2)}%)</div>`;
                }

                const storeNameStyle = isMyStore ? 'font-weight: bold;' : '';
                const marketShare = (totalPopularity > 0 && item.popularity) ? (item.popularity / totalPopularity) * 100 : 0;
                let popularityHtml = item.popularity > 0 ? `<div style="${storeNameStyle}">${item.popularity} osb. <span style="font-size: 12px; color: #666;">(${marketShare.toFixed(2)}%)</span></div>` : '<span>-</span>';

                const priceStyle = item.isBestPriceGuarantee ? 'color: #169A23;' : '';
                const bestPriceIcon = item.isBestPriceGuarantee ? `<img src="/images/TopPrice.png" alt="Gwarancja Najniższej Ceny" title="Gwarancja Najniższej Ceny" style="width: 18px; height: 18px; vertical-align: middle; margin-left: 5px;">` : '';
                const topOfferBadge = item.topOffer ? `<div class="TopOffer" style="display: inline-block; margin-left: 5px; vertical-align: middle;">Top oferta</div>` : '';
                const superPriceBadge = item.superPrice ? `<div class="SuperPrice" style="display: inline-block; margin-left: 5px; vertical-align: middle;">SUPERCENA</div>` : '';
                let boostHtml = (item.promoted ? '<div class="PromoInfo">Promowana</div>' : (item.sponsored ? '<div class="PromoInfo">Sponsorowana</div>' : '<span>-</span>'));

                let navigationHtml = '';
                if (isMyStore) {
                    if (item.targetProductId === productId) {
                        navigationHtml = `<strong>Oglądana</strong>`;
                    } else if (item.targetProductId) {
                        const detailsUrl = `/AllegroPriceHistory/Details?storeId=${storeId}&productId=${item.targetProductId}`;
                        navigationHtml = `<a href="${detailsUrl}" class="Button-Page-Small">Przejdź</a>`;
                    }
                }

                tr.innerHTML = `
                    <td><div class="color-bar ${colorClass}"></div></td>
                    <td class="store-name" style="${storeNameStyle}">${item.sellerName} ${item.superSeller ? `<img src="/images/SuperSeller.png" alt="Super Sprzedawca" title="Super Sprzedawca" style="width: 18px; height: 18px; vertical-align: middle; margin-left: 5px;">` : ''}</td>
                    <td class="store-price" style="${storeNameStyle} ${priceStyle}">${item.price.toFixed(2)} PLN ${bestPriceIcon} ${topOfferBadge} ${superPriceBadge}</td>
                    <td>${diffHtml}</td>
                    <td>${boostHtml}</td>
                    <td>${renderShippingCost(item.deliveryCost)}</td>
                    <td>${renderDeliveryInfo(item.deliveryTime)}</td>
                    <td>${item.smart ? `<div class="Smart-Allegro"><img src="/images/Smart.png" alt="Smart!" title="Smart!" style="height: 15px; width: auto;"></div>` : '<span>-</span>'}</td>
                    <td>${popularityHtml}</td>
                    <td>${navigationHtml}</td>
                    <td class="data-chanel"><img src="/images/AllegroIcon.png" alt="Allegro Icon" style="width:24px; height:24px;" /></td>
                `;
                tbody.appendChild(tr);
            });
        }
        function drawBarChart(allOffersData) {
            const ctx = document.getElementById('priceBarChart');
            if (!ctx) return;
            if (chartInstance) chartInstance.destroy();

            const reversedDataForChart = [...allOffersData].reverse();

            const labels = reversedDataForChart.map(item => item.sellerName);
            const data = reversedDataForChart.map(item => item.price);

            const barColors = reversedDataForChart.map(item => {
                if (item.targetProductId === productId) {
                    return 'rgba(255, 100, 0, 0.8)';
                } else if (item.sellerName.toLowerCase().trim() === myStoreLower) {
                    return 'rgba(255, 159, 64, 0.5)';
                } else {
                    return 'rgba(34, 34, 34, 0.4)';
                }
            });

            const borderColors = reversedDataForChart.map(item => {
                if (item.targetProductId === productId) {
                    return 'rgba(255, 100, 0, 1)';
                } else if (item.sellerName.toLowerCase().trim() === myStoreLower) {
                    return 'rgba(255, 159, 64, 1)';
                } else {
                    return 'rgba(34, 34, 34, 1)';
                }
            });

            chartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Cena PLN',
                        data: data,
                        backgroundColor: barColors,
                        borderColor: borderColors,
                        borderWidth: 2,
                        borderRadius: 2
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: false, ticks: { callback: value => value + ' PLN' } }, x: { display: false } },
                    plugins: { legend: { display: false } }
                }
            });
        }

            function updateLastScrapeDate(dateStr) {
                const lastScrapeInfo = document.getElementById('lastScrapeInfo');
                if (lastScrapeInfo && dateStr) {
                    const date = new Date(dateStr);
                    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
                    lastScrapeInfo.innerHTML = `<p><strong>Wykonano:</strong> ${date.toLocaleDateString('pl-PL', options)}</p>`;
                }
            }

            function showLoadingState() {
                if (loadingOverlay) loadingOverlay.style.display = 'flex';
                const tbody = document.querySelector("#priceTable tbody");

                if (tbody) tbody.innerHTML = '<tr><td colspan="10" style="text-align:center; padding: 40px;">Ładowanie danych...</td></tr>';
            }

            function showEmptyState() {
                if (loadingOverlay) loadingOverlay.style.display = 'none';
                const tbody = document.querySelector("#priceTable tbody");

                if (tbody) tbody.innerHTML = '<tr><td colspan="10" style="text-align:center; padding: 40px;">Brak ofert do wyświetlenia dla tego produktu.</td></tr>';
                const chartParent = document.getElementById('chartContainer');
                if (chartParent) chartParent.innerHTML = '<div style="text-align:center; padding: 40px;">Brak danych do narysowania wykresu.</div>';
            }

            showLoadingState();
            const url = `/AllegroPriceHistory/GetProductPriceDetails?storeId=${storeId}&productId=${productId}`;

            fetch(url)
                .then(response => response.ok ? response.json() : Promise.reject('Błąd sieci'))
                               .then(result => {
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            let offers = result?.data ?? [];

            if (offers.length > 0) {

                    offers.sort((a, b) => {

            if (a.price !== b.price) {
                return a.price - b.price;
            }

            const scoreA = (a.topOffer || a.superPrice || a.isBestPriceGuarantee) ? 0 : 1;
            const scoreB = (b.topOffer || b.superPrice || b.isBestPriceGuarantee) ? 0 : 1;
            if (scoreA !== scoreB) {
                return scoreA - scoreB;
            }

            const totalA = a.price + (a.deliveryCost || 0);
            const totalB = b.price + (b.deliveryCost || 0);
            if (totalA !== totalB) {
                return totalA - totalB;
            }

            return a.sellerName.localeCompare(b.sellerName);
        });

                renderTable(offers, result.totalProductPopularity, result.setPrice1, result.setPrice2, result.mainOfferId);
                drawBarChart(offers);
                updateLastScrapeDate(result.lastScrapeDate);
            } else {
                showEmptyState();
            }
        })
        });

    </script>

    <script>

            let productId = @ViewBag.ProductId;
            let myStoreLower = "@storeName".toLowerCase().trim();
            let lastHoverParams = null;

            let highlightedStores = [];
            let storeColorMap = {};
            let lastHighlightedStore = null;
            let hiddenStores = [];

        const highlightColors = [
            'rgba(54, 162, 235, 1)',
            'rgba(75, 192, 192, 1)',
            'rgba(153, 102, 255, 1)',
            'rgba(255, 99, 132, 1)',
            'rgba(0, 150, 136, 1)',
            'rgba(201, 203, 207, 1)',
            'rgba(121, 85, 72, 1)',
            'rgba(139, 195, 74, 1)',
            'rgba(0, 188, 212, 1)',
            'rgba(233, 30, 99, 1)'
        ];

                    const myMainOfferColor = 'rgba(255, 100, 0, 1)';
        const myOtherOfferColor = 'rgba(255, 159, 64, 0.7)';
        const defaultGrayColor = 'rgba(128, 128, 128, {alpha})';

        let mainOfferId = null;

                const UNIFORM_LINE_WIDTH = 2.3;
            const UNIFORM_EMPHASIS_LINE_WIDTH = 2.3;

            let defaultGrayAlpha = 0.3;
            let echartsTrendChart = null;
            let currentTimelineData = null;
            let currentChartOptions = null;
            const defaultCustomTooltipContent = 'Najedź na punkt na wykresie...';

            function updateCustomTooltipPanel(htmlContent) {
                const panelDiv = document.getElementById('customTrendTooltip');
                if (panelDiv) {
                    panelDiv.innerHTML = htmlContent || defaultCustomTooltipContent;
                } else {
                    console.error("Element '#customTrendTooltip' not found!");
                }
            }

                function recalculateYAxisRange() {
                if (!currentChartOptions || !currentChartOptions.series) {

                    return null;
                }

                let minPrice = Number.POSITIVE_INFINITY;
                let maxPrice = Number.NEGATIVE_INFINITY;
                let hasVisibleData = false;

                currentChartOptions.series.forEach(series => {
                    const storeLower = series.name.toLowerCase().trim();

                    if (!hiddenStores.includes(storeLower)) {
                        series.data.forEach(dataPoint => {
                            const price = dataPoint.value;
                            if (price !== null && price !== undefined) {
                                hasVisibleData = true;
                                if (price < minPrice) minPrice = price;
                                if (price > maxPrice) maxPrice = price;
                            }
                        });
                    }
                });

                if (!hasVisibleData || !isFinite(minPrice)) {

                     console.warn("No visible data points found after filtering. Using default Y-axis range.");
                     return { min: 0, max: 100 };
                }

                 if (!isFinite(maxPrice) || maxPrice <= minPrice) {
                     maxPrice = minPrice + 100;
                 }

                const padding = (maxPrice - minPrice) * 0.05;

                const finalMin = Math.max(0, minPrice - padding);
                const finalMax = maxPrice + padding;

                return { min: finalMin, max: finalMax };
            }

            function findNextFreeColorIndex() {
                for (let i = 0; i < highlightColors.length; i++) {
                    let used = Object.values(storeColorMap).includes(i);
                    if (!used) return i;
                }
                return null;
            }

                function hideStoreFromChart(storeName) {
                if (!echartsTrendChart || !currentTimelineData) {
                    console.warn("Chart not ready or no data to hide store.");
                    return;
                }

                const storeLower = storeName.toLowerCase().trim();

                if (!hiddenStores.includes(storeLower)) {
                    hiddenStores.push(storeLower);
                }

                const highlightedIndex = highlightedStores.indexOf(storeLower);
                if (highlightedIndex > -1) {

                    highlightedStores.splice(highlightedIndex, 1);

                    delete storeColorMap[storeLower];

                    if (lastHighlightedStore === storeLower) {
                        lastHighlightedStore = highlightedStores.length > 0 ? highlightedStores[highlightedStores.length - 1] : null;
                    }
                }

                updateEchartsStylesAndZ();
            const newYAxisRange = recalculateYAxisRange();
               if (newYAxisRange && currentChartOptions && currentChartOptions.yAxis) {

                   currentChartOptions.yAxis.min = newYAxisRange.min;
                   currentChartOptions.yAxis.max = newYAxisRange.max;

                   echartsTrendChart.setOption({
                       yAxis: {
                           min: newYAxisRange.min,
                           max: newYAxisRange.max

                       }
                   });
               }

               if (lastHoverParams) {
                   const updatedPanelHtml = generateTooltipPanelHtml(lastHoverParams);
                   updateCustomTooltipPanel(updatedPanelHtml || defaultCustomTooltipContent);
               }
            }

        function getSeriesStyleAndZ(storeNameLower, offerId) {
            if (hiddenStores.includes(storeNameLower)) {
                return {
                    lineStyle: { color: 'transparent', width: 0 },
                    itemStyle: { color: 'transparent' },
                    z: 0
                };
            }

            const isMyStore = storeNameLower === myStoreLower;

            if (isMyStore && offerId && offerId === mainOfferId) {
                return {
                    lineStyle: { color: myMainOfferColor, width: UNIFORM_LINE_WIDTH },
                    itemStyle: { color: myMainOfferColor },
                    z: 5
                };
            }

            if (isMyStore) {
                return {
                    lineStyle: { color: myOtherOfferColor, width: UNIFORM_LINE_WIDTH },
                    itemStyle: { color: myOtherOfferColor },
                    z: 4
                };
            }

            const isHighlighted = highlightedStores.includes(storeNameLower);
            const colorIndex = storeColorMap[storeNameLower];

            if (isHighlighted && colorIndex !== undefined && colorIndex !== null) {
                const isLastHighlighted = storeNameLower === lastHighlightedStore;
                return {
                    lineStyle: { color: highlightColors[colorIndex], width: UNIFORM_LINE_WIDTH },
                    itemStyle: { color: highlightColors[colorIndex] },
                    z: isLastHighlighted ? 3 : 2
                };
            }

            return {
                lineStyle: { color: defaultGrayColor.replace('{alpha}', defaultGrayAlpha), width: UNIFORM_LINE_WIDTH },
                itemStyle: { color: defaultGrayColor.replace('{alpha}', defaultGrayAlpha) },
                z: 1
            };
        }

               function generateTooltipPanelHtml(params) {
            if (!params || params.length === 0) {
                return null;
            }

            const date = params[0].axisValueLabel;
            let items = [];

            params.forEach(param => {
                const priceVal = param.data.value;
                const sourceVal = param.data.source;
                const storeName = param.seriesName;
                const offerId = param.data.idAllegro;
                const storeLower = storeName.toLowerCase().trim();

                const isBpg = param.data.isBestPriceGuarantee;
                const isTop = param.data.topOffer;
                const isSuper = param.data.superPrice;

                if (hiddenStores.includes(storeLower)) {
                    return;
                }

                if (priceVal !== null && priceVal !== undefined) {
                    items.push({
                        storeName: storeName,
                        price: priceVal,
                        offerId: offerId,
                        source: sourceVal,
                        isHighlighted: highlightedStores.includes(storeLower),
                        isMyStore: (storeLower === myStoreLower),
                        isLastHighlighted: (storeLower === lastHighlightedStore),
                        colorIndex: storeColorMap[storeLower],

                        markerColor: param.color,

                        isBestPriceGuarantee: isBpg,
                        isTopOffer: isTop,
                        isSuperPrice: isSuper
                    });
                }
            });

            items.sort((a, b) => {
                if (a.price !== b.price) {
                    return a.price - b.price;
                }
                return a.storeName.localeCompare(b.storeName);
            });

            let panelHtml = `<div style="font-weight:bold; margin-bottom:4px;">Data: ${date}</div>`;
            if (items.length > 0) {
                panelHtml += `<table style="width:100%; border-collapse:collapse; font-size: 0.85rem;">`;
                items.forEach(item => {
                    let colorText = 'rgba(50, 50, 50, 1)';
                    let fontWeight = 'normal';
                    const storeLower = item.storeName.toLowerCase().trim();

                    if (item.isMyStore) {
                        if (item.offerId && item.offerId === mainOfferId) {
                            colorText = myMainOfferColor;
                        } else {
                            colorText = myOtherOfferColor;
                        }
                        fontWeight = 'bold';
                    } else if (item.isHighlighted && item.colorIndex != null) {
                        colorText = highlightColors[item.colorIndex];
                        fontWeight = 'bold';
                    }

                    let displayName = item.storeName;
                    if (displayName.length > 23) displayName = displayName.substring(0, 20) + '...';

                          let badgesHtml = '';
                            if (item.isBestPriceGuarantee) {
                                badgesHtml += ` <img src="/images/TopPrice.png" alt="Gwarancja Najniższej Ceny" title="Gwarancja Najniższej Ceny" style="height: 14px; vertical-align: middle; margin-left: 3px;">`;
                            }
                            if (item.isTopOffer) {
                                badgesHtml += ` <div class="TopOffer" style="display: inline-block; font-size: 0.7rem; vertical-align: middle; margin-left: 3px;">Top oferta</div>`;
                            }
                            if (item.isSuperPrice) {
                                badgesHtml += ` <div class="SuperPrice" style="display: inline-block; font-size: 0.7rem; vertical-align: middle; margin-left: 3px;">SUPERCENA</div>`;
                            }

                            const iconHtml = `<img src="/images/AllegroIcon.png" alt="Allegro" style="width:14px; height:14px; margin-right:4px; vertical-align: middle;" title="Allegro" />`;
                            const escapedStoreName = item.storeName.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;');

                            const removeButtonHtml = `
                                <span class="remove-store-btn" title="Ukryj sklep '${item.storeName}' z wykresu"
                                        style="cursor: pointer; color: #aaa; margin-left: 8px; font-weight: bold; padding: 0 4px; display: inline-block; vertical-align: middle;"
                                        onmouseover="this.style.color='red'"
                                        onmouseout="this.style.color='#aaa'"
                                        onclick="event.stopPropagation(); hideStoreFromChart('${escapedStoreName}');">
                                        &times;
                                </span>`;

                            panelHtml += `
                                <tr style="border-bottom:1px solid #eee; cursor:pointer;"
                                    onclick="event.stopPropagation(); toggleStoreHighlight('${escapedStoreName}');">
                                    <td style="padding: 3px 2px; color:${colorText}; font-weight:${fontWeight}; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="${item.storeName}">
                                        <span style="display:inline-block; margin-right:5px; border-radius:10px; width:10px; height:10px; background-color:${item.markerColor}; vertical-align: middle;"></span>
                                        ${iconHtml}${displayName}
                                    </td>
                                    <td style="padding: 3px 2px; text-align:right; color:${colorText}; font-weight:${fontWeight}; white-space:nowrap;">
                                        ${badgesHtml}
                                        <span style="vertical-align: middle;">${item.price.toFixed(2)} PLN</span>
                                        ${removeButtonHtml}
                                    </td>
                                </tr>
                            `;
                });
                panelHtml += `</table>`;
            } else {
                const hasAnyDataForDate = params.some(p => p.data.value !== null && p.data.value !== undefined);
                if(hasAnyDataForDate) {
                    panelHtml += `<div style="color: #666; font-style: italic;">Wszystkie widoczne sklepy nie miały oferty w tej dacie lub zostały ukryte.</div>`;
                } else {
                    panelHtml += `<div style="color: #666; font-style: italic;">Brak danych dla tej daty.</div>`;
                }
            }
            return panelHtml;
        }

           function prepareEchartsSeries(dataByInstance, allDates, allInstances) {

        const specialOfferIconUrl = 'image:///images/TopPrice.png';

        const SINGLE_POINT_SIZE = 10;
        const MULTI_POINT_EMPHASIS_SIZE = 12;
        const SINGLE_POINT_EMPHASIS_SIZE = 14;
        const SPECIAL_POINT_SIZE = 16;
        const SPECIAL_POINT_EMPHASIS_SIZE = 20;

        return allInstances.map(instanceId => {
            const [storeName, offerIdStr, source] = instanceId.split('|');
            const offerId = parseInt(offerIdStr, 10);
            const storeLower = storeName.toLowerCase().trim();
            const initialStyleAndZ = getSeriesStyleAndZ(storeLower, offerId);

            let validDataPointsCount = 0;

            const data = allDates.map(date => {
                const pointData = dataByInstance[instanceId]?.[date] ?? {};
                const price = pointData.price;
                if (price !== null && price !== undefined) {
                    validDataPointsCount++;
                }

                return {
                    value: price,
                    source: pointData.source,
                    storeName: pointData.storeName,
                    idAllegro: pointData.idAllegro,
                    isBestPriceGuarantee: pointData.isBestPriceGuarantee,
                    topOffer: pointData.topOffer,
                    superPrice: pointData.superPrice
                };
            });

            const styledData = data.map(point => {
                const hasSpecialBadge = point.isBestPriceGuarantee || point.topOffer || point.superPrice;
                const isSinglePointSeries = validDataPointsCount === 1;

                let symbol = 'circle';
                let symbolSize = isSinglePointSeries ? SINGLE_POINT_SIZE : 6;

                if (hasSpecialBadge) {

                    symbol = specialOfferIconUrl;
                    symbolSize = isSinglePointSeries ? SPECIAL_POINT_EMPHASIS_SIZE : SPECIAL_POINT_SIZE;
                }

                return {
                    ...point,
                    symbol: symbol,
                    symbolSize: symbolSize
                };
            });

                let showSymbolDefault = (validDataPointsCount === 1);
                let symbolSizeDefault = (validDataPointsCount === 1) ? SINGLE_POINT_SIZE : 6;
                let symbolSizeEmphasis = (validDataPointsCount === 1) ? SINGLE_POINT_EMPHASIS_SIZE : MULTI_POINT_EMPHASIS_SIZE;

                return {
                    name: storeName,
                    _instanceId: instanceId,
                    _source: source,
                    type: 'line',

                    data: styledData,
                    connectNulls: false,
                    smooth: 0.30,

                    showSymbol: showSymbolDefault,
                    symbol: 'circle',
                    symbolSize: symbolSizeDefault,

                    emphasis: {
                        focus: 'series',

                        lineStyle: {
                            width: UNIFORM_EMPHASIS_LINE_WIDTH
                        },
                        itemStyle: {
                            color: initialStyleAndZ.itemStyle.color,
                            borderColor: 'rgba(255, 255, 255, 0.7)',
                            borderWidth: 1,
                            opacity: 1
                        }
                    },
                    lineStyle: initialStyleAndZ.lineStyle,
                    itemStyle: {
                        color: initialStyleAndZ.itemStyle.color
                    },
                    z: initialStyleAndZ.z
                };
            });
        }
            function drawEchartsTrendChart(timelineData) {
                currentTimelineData = timelineData;

                const chartDom = document.getElementById('trendChart');
                if (!chartDom) {
                    console.error("ECharts container 'trendChart' not found!");
                    return;
                }

                if (echartsTrendChart) {
                    echartsTrendChart.dispose();
                    echartsTrendChart = null;
                }

                echartsTrendChart = echarts.init(chartDom);

            let allDatesSet = new Set();
            let allInstancesSet = new Set();
            let dataByInstance = {};

        timelineData.forEach(entry => {
            const date = entry.scrapDate;
            allDatesSet.add(date);

            entry.pricesByStore.forEach(priceObject => {

                const instanceId = `${priceObject.storeName}|${priceObject.idAllegro}|${priceObject.source}`;
                allInstancesSet.add(instanceId);

                if (!dataByInstance[instanceId]) {
                    dataByInstance[instanceId] = {};
                }

                dataByInstance[instanceId][date] = priceObject;
            });
        });

            const chartContainerElement = document.getElementById('trendChartContainer');

            if (chartContainerElement && typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(entries => {

                    if (echartsTrendChart && $('#trendChartContainer').is(':visible')) {
                         console.log('ResizeObserver detected container resize, resizing ECharts.');

                         echartsTrendChart.resize({
                            animation: {
                                duration: 200,
                                easing: 'quadraticInOut'
                            }
                         });
                    }
                });

                resizeObserver.observe(chartContainerElement);

            } else if (!chartContainerElement) {

            }
             else {

            }

            let allDates = Array.from(allDatesSet).sort();
            let allInstances = Array.from(allInstancesSet);

            allInstances.sort((a, b) => {
                const [nameA, sourceA] = a.split('|');
                const [nameB, sourceB] = b.split('|');
                const nameALower = nameA.toLowerCase().trim();
                const nameBLower = nameB.toLowerCase().trim();
                if (nameALower === myStoreLower && nameBLower !== myStoreLower) return -1;
                if (nameBLower === myStoreLower && nameALower !== myStoreLower) return 1;
                const nameCompare = nameA.localeCompare(nameB);
                if (nameCompare !== 0) return nameCompare;
                return sourceA.localeCompare(sourceB);
            });

        let globalMinPrice = Number.POSITIVE_INFINITY;
        let globalMaxPrice = Number.NEGATIVE_INFINITY;
        Object.values(dataByInstance).forEach(datesMap => {
            Object.values(datesMap).forEach(priceObject => {
                if (priceObject && priceObject.price != null) {
                    if (priceObject.price < globalMinPrice) globalMinPrice = priceObject.price;
                    if (priceObject.price > globalMaxPrice) globalMaxPrice = priceObject.price;
                }
            });
        });

             if (!isFinite(globalMinPrice)) globalMinPrice = 0;
             if (!isFinite(globalMaxPrice) || globalMaxPrice <= globalMinPrice) {
                 globalMaxPrice = globalMinPrice + 100;
             } else {
                 const padding = (globalMaxPrice - globalMinPrice) * 0.05;
                 globalMinPrice = Math.max(0, globalMinPrice - padding);
                 globalMaxPrice = globalMaxPrice + padding;
             }

            const seriesData = prepareEchartsSeries(dataByInstance, allDates, allInstances);

            const polishMonths = [
                'sty', 'lut', 'mar', 'kwi', 'maj', 'cze',
                'lip', 'sie', 'wrz', 'paź', 'lis', 'gru'
            ];

            function formatDateToPolishDM(dateString) {
                try {

                    const parts = dateString.split('-');
                    if (parts.length === 3) {
                        const day = parseInt(parts[2], 10);
                        const monthIndex = parseInt(parts[1], 10) - 1;
                        if (!isNaN(day) && monthIndex >= 0 && monthIndex < 12) {
                            return `${day} ${polishMonths[monthIndex]}`;
                        }
                    }

                    return dateString;
                } catch (e) {
                    console.error("Error formatting date:", dateString, e);
                    return dateString;
                }
            }

            currentChartOptions = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'cross',
                        snap: true,
                        label: { backgroundColor: '#6a7985' }
                    },

                    formatter: function (params) {
                        lastHoverParams = params;
                        const panelHtml = generateTooltipPanelHtml(params);
                        updateCustomTooltipPanel(panelHtml || defaultCustomTooltipContent);
                        return '';
                    },

                },
                xAxis: {
                    type: 'category',
                    data: allDates,
                    splitLine: {
                        show: true,
                        lineStyle: {
                            color: '#E8E8E8',
                            type: 'dashed',
                            width: 1,
                            opacity: 1.0
                        }
                    },
                    boundaryGap: false,
                      axisLabel: {

                        formatter: function (value) {

                            return formatDateToPolishDM(value);
                        },

                        fontSize: 11,
                        color: '#666'

                    }

                },
                    yAxis: {
                    type: 'value',
                    min: globalMinPrice,
                    max: globalMaxPrice,
                    axisLabel: {
                         show: false,
                         formatter: function (value) {  }
                    },
                    scale: true,
                    axisPointer: {
                        show: true,
                        snap: true
                    },
                    splitLine: {
                        show: true,
                        lineStyle: {
                            color: '#E8E8E8',
                            type: 'dashed',
                            width: 1,
                            opacity: 1.0
                        }
                    }
                },
                grid: {
                    left: '3%',
                    right: '4%',

                    bottom: '80px',
                    containLabel: true
                },
                series: seriesData,
                animationEasing: 'quadraticInOut',
                animationDuration: 600,

            dataZoom: [
                {
                    type: 'slider',
                    xAxisIndex: 0,
                    start: 0,
                    end: 100,
                    bottom: '10px',
                    height: 25,
                    showDetail: true,
                    realtime: true,
                    filterMode: 'filter',

                    backgroundColor: 'rgba(240, 240, 240, 0.6)',
                    borderColor: '#cccccc',
                    fillerColor: 'rgba(180, 180, 180, 0.4)',
                    handleStyle: {
                        color: '#a7a7a7',
                        borderColor: '#747474',
                        borderWidth: 1
                    },
                    dataBackground: {
                        lineStyle: { color: 'transparent' },
                        areaStyle: { color: '#ebebeb' }
                    },
                    selectedDataBackground: {
                        lineStyle: { color: 'transparent' },
                        areaStyle: { color: '#dcdcdc' }
                    },

                    showMoveHandle: false,

                    moveHandleIcon: 'none',
                    moveHandleStyle: {
                        color: 'transparent',
                        opacity: 0
                    },

                    emphasis: {
                        fillerColor: 'rgba(180, 180, 180, 0.6)',
                        handleStyle: {
                            color: '#747474',
                            borderColor: '#505050'
                        },
                        moveHandleStyle: {
                            color: 'transparent',
                            opacity: 0
                        }
                    },
                     labelFormatter: function (value) {

                            let dateStr = '';

                            if (typeof value === 'number' && value >= 0 && value < allDates.length) {

                                dateStr = allDates[value];
                            } else if (typeof value === 'string') {

                                 dateStr = value;
                            } else {

                                 return '';
                            }

                            return formatDateToPolishDM(dateStr);
                        }

                },
                {
                    type: 'inside',
                    xAxisIndex: 0,
                    start: 0,
                    end: 100,
                    zoomOnMouseWheel: true,
                    moveOnMouseMove: true,
                    preventDefaultMouseMove: true
                }
            ]
            };

                echartsTrendChart.setOption(currentChartOptions);

                echartsTrendChart.on('click', function (params) {
                 if (params && params.seriesName) {
                     const clickedStoreName = params.seriesName;

                     toggleStoreHighlight(clickedStoreName);
                 }
             });

                echartsTrendChart.on('mouseout', function () {

                });

                window.addEventListener('resize', () => {
                    if (echartsTrendChart) {
                        echartsTrendChart.resize();
                    }
                });

                updateCustomTooltipPanel(null);
            }

            function toggleStoreHighlight(storeName) {
                if (!echartsTrendChart || !currentTimelineData) {
                    console.warn("Chart not ready or no data to toggle highlight.");
                    return;
                }
                let sLower = storeName.toLowerCase().trim();
                let idx = highlightedStores.indexOf(sLower);

                if (idx >= 0) {
                    highlightedStores.splice(idx, 1);
                    delete storeColorMap[sLower];
                    if (lastHighlightedStore === sLower) {
                         lastHighlightedStore = highlightedStores.length > 0 ? highlightedStores[highlightedStores.length - 1] : null;
                    }
                } else {
                    if (sLower === myStoreLower) {
                         console.log("Kliknięto własny sklep - brak dodatkowego podświetlenia.");
                         lastHighlightedStore = sLower;
                    } else if (highlightedStores.length >= highlightColors.length) {
                         alert(`Możesz zaznaczyć maks. ${highlightColors.length} sklepów do porównania `);
                         return;
                    } else {
                         let cIndex = findNextFreeColorIndex();
                         if (cIndex === null) {
                             alert("Brak wolnych kolorów do podświetlenia!");
                             return;
                         }
                         if (!highlightedStores.includes(sLower)) {
                             highlightedStores.push(sLower);
                         }
                         storeColorMap[sLower] = cIndex;
                         lastHighlightedStore = sLower;
                    }
                }

                updateEchartsStylesAndZ();

                if (lastHoverParams) {

                    const updatedPanelHtml = generateTooltipPanelHtml(lastHoverParams);
                    if (updatedPanelHtml) {
                         updateCustomTooltipPanel(updatedPanelHtml);
                    }
                }

            }

                   function updateEchartsStylesAndZ() {
            if (!echartsTrendChart || !currentChartOptions || !currentChartOptions.series) return;

            const updatedSeries = currentChartOptions.series.map(series => {
                const storeLower = series.name.toLowerCase().trim();

                let offerId = null;
                if (series._instanceId) {
                    const parts = series._instanceId.split('|');
                    if (parts.length > 1) {
                        offerId = parseInt(parts[1], 10);
                    }
                }

                const styleAndZ = getSeriesStyleAndZ(storeLower, offerId);

                const currentEmphasis = series.emphasis || {};
                const currentEmphasisItemStyle = currentEmphasis.itemStyle || {};
                const currentEmphasisLineStyle = currentEmphasis.lineStyle || {};

                const newEmphasis = {
                    ...currentEmphasis,
                    lineStyle: {
                        ...currentEmphasisLineStyle,
                        width: UNIFORM_EMPHASIS_LINE_WIDTH
                    },
                    itemStyle: {
                        ...currentEmphasisItemStyle,
                        color: styleAndZ.itemStyle.color,
                        opacity: 1
                    }
                };

                return {
                    ...series,
                    lineStyle: styleAndZ.lineStyle,
                    itemStyle: styleAndZ.itemStyle,
                    emphasis: newEmphasis,
                    z: styleAndZ.z
                };
            });

            currentChartOptions.series = updatedSeries;

            echartsTrendChart.setOption({
                series: updatedSeries
            });

        }

            document.addEventListener("DOMContentLoaded", function () {
                 const $exportExcelBtn = $('#exportExcelBtn');
                const $showTableBtn = $('#showTableBtn');
                const $showChartBtn = $('#showChartBtn');
                const $tableContainer = $('#priceTableContainer');
                const $chartContainer = $('#trendChartContainer');
                const $customTooltipPanel = $('#customTrendTooltip');

                $showTableBtn.on('click', function () {
                    $chartContainer.hide();
                    $customTooltipPanel.hide();
                    $tableContainer.show();
                    $showTableBtn.removeClass('button-inactive').addClass('button-active');
                    $showChartBtn.removeClass('button-active').addClass('button-inactive');
                });

                $showChartBtn.on('click', function () {
                    $tableContainer.hide();
                    $chartContainer.show();
                    $customTooltipPanel.show();
                    $showChartBtn.removeClass('button-inactive').addClass('button-active');
                    $showTableBtn.removeClass('button-active').addClass('button-inactive');

                    if ($chartContainer.is(':visible')) {
                         if (!echartsTrendChart && currentTimelineData) {
                             if (document.getElementById('trendChart')) {
                                  drawEchartsTrendChart(currentTimelineData);
                             } else {
                                  console.error("Target div 'trendChart' not found when trying to redraw.");
                             }
                         } else if (!echartsTrendChart) {
                              if (document.getElementById('trendChart')) {
                                  loadTrendDataAndDrawEcharts();
                              } else {
                                  console.error("Target div 'trendChart' not found on initial load.");
                              }
                         } else {
                             echartsTrendChart.resize();
                         }
                    }
                });

            if ($exportExcelBtn.length) {
                $exportExcelBtn.on('click', function() {

                    if (!currentTimelineData) {
                        alert("Dane historii cen nie zostały jeszcze załadowane. Proszę najpierw kliknąć przycisk 'Wykres'.");

                    } else {
                        exportChartDataToExcel();
                    }
                });
            }

                const grayAlphaRange = document.getElementById("grayAlphaRange");
                if (grayAlphaRange) {
                    grayAlphaRange.addEventListener("input", function (e) {
                        defaultGrayAlpha = parseFloat(e.target.value);
                        updateEchartsStylesAndZ();

                         if (lastHoverParams) {
                            const updatedPanelHtml = generateTooltipPanelHtml(lastHoverParams);
                            if (updatedPanelHtml) {
                                 updateCustomTooltipPanel(updatedPanelHtml);
                            }
                         }
                    });
                }

                 $showTableBtn.click();

            });

            function loadTrendDataAndDrawEcharts() {
                 if ($('#trendChartContainer').is(':visible')) {
                      $('#loadingOverlay').show();
                 }

                $.ajax({
                url: '@Url.Action("GetPriceTrendData", "AllegroPriceHistory")',
                    type: 'GET',
                    data: { productId: productId },
                    success: function(response) {
                        if (response && response.timelineData && Array.isArray(response.timelineData)) {

        currentTimelineData = response.timelineData;
        mainOfferId = response.mainOfferId;

        if ($('#trendChartContainer').is(':visible') && document.getElementById('trendChart')) {
            drawEchartsTrendChart(currentTimelineData);
        } else {
            console.log("Chart container not visible, data stored for later drawing.");
        }
                        } else {
                             alert("Otrzymano nieprawidłowy format danych trendu.");
                             console.error("Invalid timeline data received:", response);
                             updateCustomTooltipPanel('<div style="color:red;">Błąd ładowania danych.</div>');
                        }
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        alert("Błąd pobierania danych trendu: " + errorThrown);
                        console.error("AJAX Error:", textStatus, errorThrown);
                         updateCustomTooltipPanel('<div style="color:red;">Błąd ładowania danych.</div>');
                    },
                    complete: function() {
                         $('#loadingOverlay').hide();
                    }
                });
            }

            function rgbaToHex(rgba) {

                if (typeof rgba !== 'string' || !rgba.toLowerCase().startsWith('rgba')) {
                    return null;
                }
                const parts = rgba.substring(rgba.indexOf('(') + 1, rgba.lastIndexOf(')')).split(/,\s*/);
                if (parts.length < 3) {
                    return null;
                }
                try {
                    const r = parseInt(parts[0], 10);
                    const g = parseInt(parts[1], 10);
                    const b = parseInt(parts[2], 10);
                    if (isNaN(r) || isNaN(g) || isNaN(b) || r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                        return null;
                    }
                    const toHex = c => ('0' + c.toString(16)).slice(-2);
                    const hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();

                    return hex;
                } catch (e) {
                    return null;
                }
            }

            function getExcelColorForStoreWithInfo(storeKey, currentStoreInfo) {

                if (!currentStoreInfo || !storeKey || !currentStoreInfo[storeKey]) {

                    return null;
                }

                const name = currentStoreInfo[storeKey].name;
                const storeLower = name.toLowerCase().trim();

                let colorToConvert = null;

                const isMy = (typeof myStoreLower !== 'undefined' && storeLower === myStoreLower);

                if (isMy && typeof myStoreColor !== 'undefined') {
                    colorToConvert = myStoreColor;

                }

                const isHighlighted = (typeof highlightedStores !== 'undefined' && Array.isArray(highlightedStores) && highlightedStores.includes(storeLower));

                 if (!isMy && isHighlighted) {
                    if (typeof storeColorMap !== 'undefined' && typeof highlightColors !== 'undefined' && Array.isArray(highlightColors)) {
                        const colorIndex = storeColorMap[storeLower];

                        if (colorIndex !== undefined && colorIndex !== null && colorIndex < highlightColors.length) {
                            colorToConvert = highlightColors[colorIndex];

                        } else {

                        }
                    } else {

                    }
                }

                if (colorToConvert) {
                    const hexColor = rgbaToHex(colorToConvert);

                    return hexColor;
                }

                return null;
            }

            async function exportChartDataToExcel() {
                console.log("==============================================");
                console.log("Rozpoczynanie eksportu do Excel używając ExcelJS (uwzględniając zoom)...");

                if (!currentTimelineData || currentTimelineData.length === 0) {
                    alert("Brak danych historii cen do wyeksportowania. Najpierw załaduj widok wykresu.");
                    console.warn("Brak danych w currentTimelineData do eksportu.");
                    return;
                }
                if (!echartsTrendChart) {
                    alert("Instancja wykresu nie jest dostępna. Najpierw załaduj widok wykresu.");
                    console.warn("Instancja echartsTrendChart nie znaleziona.");
                    return;
                }
                 if (typeof hiddenStores === 'undefined' || !Array.isArray(hiddenStores)) {
                    console.warn("Zmienna hiddenStores nie jest zdefiniowana jako tablica. Eksportowane będą wszystkie dane.");
                }

                const allDates = new Set();
                const storeData = {};
                const localStoreInfo = {};

                currentTimelineData.forEach(entry => {
                    const date = entry.scrapDate;
                    allDates.add(date);
                       entry.pricesByStore.forEach(ps => {

            if (ps.storeName && ps.source && ps.price !== null && ps.price !== undefined && ps.idAllegro) {
                const storeName = ps.storeName;
                const source = ps.source;
                const price = ps.price;
                const offerId = ps.idAllegro;

                const instanceId = `${storeName}|${offerId}|${source}`;

                allInstancesSet.add(instanceId);
                if (!dataByInstance[instanceId]) {
                    dataByInstance[instanceId] = {};
                }

                dataByInstance[instanceId][date] = price;
            }

        });
                });

                const sortedDates = Array.from(allDates).sort();

                console.log("Odczytywanie aktualnego zakresu zoomu z wykresu...");
                const option = echartsTrendChart.getOption();
                let zoomStartIndex = 0;
                let zoomEndIndex = sortedDates.length - 1;
                let dateRangeAvailable = false;

                if (option && option.dataZoom && Array.isArray(option.dataZoom) && option.dataZoom.length > 0) {

                    const dataZoomConfig = option.dataZoom.find(dz => dz.xAxisIndex === 0 || typeof dz.xAxisIndex === 'undefined');

                    if (dataZoomConfig && typeof dataZoomConfig.start !== 'undefined' && typeof dataZoomConfig.end !== 'undefined') {
                         const totalDates = sortedDates.length;

                         zoomStartIndex = Math.floor(totalDates * (dataZoomConfig.start / 100));

                         zoomEndIndex = Math.ceil(totalDates * (dataZoomConfig.end / 100)) - 1;

                         zoomStartIndex = Math.max(0, zoomStartIndex);
                         zoomEndIndex = Math.min(totalDates - 1, zoomEndIndex);
                         if(zoomStartIndex > zoomEndIndex && totalDates > 0) {
                             zoomEndIndex = zoomStartIndex;
                             console.warn("Obliczony startIndex był większy niż endIndex, skorygowano.");
                         }

                         console.log(`Zoom wykryty: start=${dataZoomConfig.start}%, end=${dataZoomConfig.end}%. Obliczone indeksy [${zoomStartIndex}, ${zoomEndIndex}] w tablicy ${totalDates} dat.`);
                         dateRangeAvailable = true;
                    } else {
                         console.warn("Nie można odczytać wartości 'start'/'end' z konfiguracji dataZoom.");
                    }
                } else {
                    console.warn("Nie znaleziono konfiguracji dataZoom w opcjach wykresu.");
                }

                const filteredDates = sortedDates.slice(zoomStartIndex, zoomEndIndex + 1);

                if (filteredDates.length === 0 && sortedDates.length > 0) {
                    alert("Brak danych w wybranym zakresie dat na wykresie do wyeksportowania.");
                    console.warn("Tablica dat po filtracji jest pusta.");
                    return;
                } else if(filteredDates.length === 0 && sortedDates.length === 0) {
                     alert("Brak jakichkolwiek danych historycznych do wyeksportowania.");
                     console.warn("Brak jakichkolwiek dat do przetworzenia.");
                     return;
                }
                console.log(`Eksportowany zakres dat: ${filteredDates.length} dni, od ${filteredDates[0]} do ${filteredDates[filteredDates.length - 1]}`);

                const sortedStoreKeys = Object.keys(storeData).sort((a, b) => {

                     if (!localStoreInfo[a] || !localStoreInfo[b]) return 0;
                    const nameA = localStoreInfo[a].name.toLowerCase();
                    const nameB = localStoreInfo[b].name.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    const sourceA = localStoreInfo[a].source.toLowerCase();
                    const sourceB = localStoreInfo[b].source.toLowerCase();
                    if (sourceA < sourceB) return -1;
                    if (sourceA > sourceB) return 1;
                    return 0;
                });

                 if (sortedStoreKeys.length === 0) {
                    alert("Brak widocznych danych sklepów do wyeksportowania (mogły zostać ukryte).");
                    console.warn("Brak kluczy sklepów do eksportu po odfiltrowaniu ukrytych sklepów.");
                    return;
                }
                console.log(`Przygotowano ${sortedStoreKeys.length} wierszy danych (sklepów).`);

                try {
                    console.log("Tworzenie skoroszytu ExcelJS...");
                    const workbook = new ExcelJS.Workbook();
                    const worksheet = workbook.addWorksheet("Historia Cen (Przestawiona)");

                    console.log("Definiowanie kolumn dla przefiltrowanych dat...");
                    const columns = [
                        { header: 'Sklep', key: 'store', width: 35 },
                        { header: 'Źródło', key: 'source', width: 10 }
                    ];
                    filteredDates.forEach(date => {
                        columns.push({
                            header: date,
                            key: date,
                            width: 12,
                            style: { numFmt: '#,##0.00', alignment: { horizontal: 'right' } }
                        });
                    });
                    worksheet.columns = columns;
                    console.log(`Zdefiniowano ${columns.length} kolumn.`);

                    console.log("Dodawanie wierszy i aplikowanie stylów...");
                    let stylesAppliedCount = 0;
                    sortedStoreKeys.forEach(storeKey => {
                        const info = localStoreInfo[storeKey];
                        const prices = storeData[storeKey];
                        const rowData = { store: info.name, source: info.source };

                        filteredDates.forEach(date => {
                            rowData[date] = prices[date] !== undefined ? prices[date] : null;
                        });

                        const row = worksheet.addRow(rowData);
                        const hexColor = getExcelColorForStoreWithInfo(storeKey, localStoreInfo);

                        if (hexColor) {
                            stylesAppliedCount++;
                            const excelJsFillStyle = { type: 'pattern', pattern:'solid', fgColor:{ argb:'FF' + hexColor.substring(1) } };
                            row.eachCell({ includeEmpty: true }, function(cell) { cell.fill = excelJsFillStyle; });
                        }
                    });
                    console.log(`Style kolorów tła zaaplikowane dla ${stylesAppliedCount} wierszy.`);

                    console.log("Generowanie bufora pliku Excel...");
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

                    const productNameJs = @Html.Raw(Json.Serialize(ViewBag.ProductName ?? "Produkt"));
                    const productNameSafe = productNameJs.replace(/[^a-z0-9_]/gi, '_').substring(0, 50);
                    const startDate = filteredDates[0];
                    const endDate = filteredDates[filteredDates.length - 1];

                    const fileName = `PriceSafari_${productNameSafe}_historia_${startDate}_do_${endDate}.xlsx`;
                    console.log("Generowanie linku do pobrania pliku:", fileName);

                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => { URL.revokeObjectURL(link.href); }, 100);

                    console.log("Pobieranie pliku zainicjowane przez ExcelJS.");

                } catch (error) {
                    console.error("Błąd podczas generowania pliku Excel za pomocą ExcelJS:", error);
                    alert("Wystąpił błąd podczas tworzenia pliku Excel...");
                }
            }

    </script>
}